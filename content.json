{"meta":{"title":"Wiki","subtitle":"Quick notes","description":"技术,前端,交流","author":"北极丶企鹅","url":"https://syhyz1990.github.io"},"pages":[],"posts":[{"title":"nodejs 搭建 TCP 转发服务","slug":"nodejs-socket","date":"2018-06-06T08:44:40.000Z","updated":"2018-06-06T08:57:19.748Z","comments":true,"path":"wiki/nodejs-socket.html","link":"","permalink":"https://syhyz1990.github.io/wiki/nodejs-socket.html","excerpt":"","text":"前言最近一直在研究高精度定位方面，公司提供了一台司南M300作为接收机。接收机接收的数据支持通过TCP协议通讯，于是需要一个搭建TCP服务器接受M300的数据，以下为通过nodejs搭建的TCP 服务器和模拟的客户端 服务端代码server.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Nodejs TCP服务器转发数据 * User: syhyz1990@qq.com * Date: 18-06-06 * Time: 下午3:44 */const net = require('net');const PORT = 1504; //定义端口号let idRecorder = 1; //id初始编号const server = net.createServer();//需要登陆的客户端const sockets = [];//接受新的客户端连接 server.on('connection', function (socket) &#123; socket._id = idRecorder++; console.log(`当前connection_id: $&#123;socket._id&#125;`); //从连接中读取数据 socket.on('data', function (data) &#123; console.log('got data:', data); //判断是否是终端用户 if (data.toString().trim() === 'GET/RTCM32,UserName=\"ABC\",Pawword=\"ABC\"\\\\r\\\\n') &#123; sockets.push(socket); console.log('模拟终端已登录'); &#125; //广播数据 //每当一个已连接的用户输入数据，就将这些数据广播给其他所有已登录用户 sockets.forEach(function (otherSocket) &#123; //console.log(otherSocket.remoteAddress + ':' + otherSocket.remotePort); if (otherSocket !== socket) &#123; otherSocket.write(data); &#125; &#125;); //删除被关闭的连接 socket.on('close', function () &#123; console.log('connection closed'); const index = sockets.indexOf(socket); sockets.splice(index, 1); &#125;); &#125;); //console.log(sockets);&#125;);server.on('error', function (err) &#123; console.log('Server error:', err.message);&#125;);server.on('close', function () &#123; console.log('Server closed');&#125;);server.listen(PORT); 客户端代码client.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152let net = require('net');let port = 1504;let quitting = false;let conn;let retryTimeout = 3000; //三秒，定义三秒后重新连接let retriedTimes = 0; //记录重新连接的次数let maxRetries = 10; //最多重新连接十次process.stdin.resume(); //process.stdin流来接受用户的键盘输入，这个可读流初始化时处于暂停状态，调用流上的resume()方法来恢复流process.stdin.on('data', function(data)&#123; if (data.toString().trim().toLowerCase() === 'quit')&#123; quitting = true; console.log('quitting'); conn.end(); process.stdin.pause(); &#125; else &#123; conn.write(data); &#125;&#125;);//连接时设置最多连接十次，并且开启定时器三秒后再连接(function connect() &#123; function reconnect() &#123; if (retriedTimes &gt;= maxRetries) &#123; throw new Error('Max retries have been exceeded, I give up.'); &#125; retriedTimes +=1; setTimeout(connect, retryTimeout); &#125; conn = net.createConnection(port); conn.on('connect', function() &#123; retriedTimes = 0; console.log('connect to server'); &#125;); conn.on('error', function(err) &#123; console.log('Error in connection:', err); &#125;); conn.on('close', function() &#123; if(! quitting) &#123; console.log('connection got closed, will try to reconnect'); reconnect(); &#125; &#125;); //打印 conn.pipe(process.stdout, &#123;end: false&#125;);&#125;)();","categories":[{"name":"技术文档","slug":"技术文档","permalink":"https://syhyz1990.github.io/categories/技术文档/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://syhyz1990.github.io/tags/nodejs/"}]},{"title":"正则表达式","slug":"regexp","date":"2018-06-05T09:38:04.000Z","updated":"2018-06-05T10:01:59.398Z","comments":true,"path":"wiki/regexp.html","link":"","permalink":"https://syhyz1990.github.io/wiki/regexp.html","excerpt":"","text":"POSIX正则表达式规范字符类 字符 含义 举例 . 匹配任意一个字符 abc.可以匹配abcd、abc9等 [] 匹配括号中的任意一个字符 [abc]d可以匹配ad、bd或cd - 在[]括号内表示字符范围 [0-9a-fA-F]可以匹配一位十六进制数字 ^ 位于[]括号内的开头，匹配除括号中的字符之外的任意一个字符 [^xy]匹配除xy之外的任一字符，因此[^xy]1可以匹配a1、b1但不匹配x1、y1 [[:xxx:]] grep工具预定义的一些命名字符类 [[:alpha:]]匹配一个字母，[[:digit:]]匹配一个数字 数量限定符 字符 含义 举例 ? 紧跟在它前面的单元应匹配零次或一次 [0-9]?\\.[0-9]匹配0.0、2.3、.5等，由于.在正则表达式中是一个特殊字符，所以需要用\\转义一下，取字面值 + 紧跟在它前面的单元应匹配一次或多次 [a-zA-Z0-9_.-]+@[a-zA-Z0-9_.-]+\\.[a-zA-Z0-9_.-]+匹配email地址 * 紧跟在它前面的单元应匹配零次或多次 [0-9][0-9]*匹配至少一位数字，等价于[0-9]+，[a-zA-Z_]+[a-zA-Z_0-9]*匹配C语言的标识符 {N} 紧跟在它前面的单元应精确匹配N次 [1-9][0-9]{2}匹配从100到999的整数 {N,} 紧跟在它前面的单元应匹配至少N次 [1-9][0-9]{2,}匹配三位以上（含三位）的整数 {,M} 紧跟在它前面的单元应匹配最多M次 [0-9]{,1}相当于[0-9]? {N,M} 紧跟在它前面的单元应匹配至少N次，最多M次 [0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}匹配IP地址 位置限定符 字符 含义 举例 ^ 匹配行首的位置 ^Content匹配位于一行开头的Content $ 匹配行末的位置 ;$匹配位于一行结尾的;号，^$匹配空行 \\&amp;lt; 匹配单词开头的位置 \\&amp;lt;th匹配… this，但不匹配ethernet、tenth \\&amp;gt; 匹配单词结尾的位置 p\\&amp;gt;匹配leap …，但不匹配parent、sleepy \\b 匹配单词开头或结尾的位置 \\bat\\b匹配… at …，但不匹配cat、atexit、batch \\B 匹配非单词开头和结尾的位置 \\Bat\\B匹配battery，但不匹配… attend、hat … 其他特殊字符 字符 含义 举例 \\ | 转义字符，普通字符转义为特殊字符，特殊字符转义为普通字符 | 普通字符&amp;lt;写成\\&amp;lt;表示单词开头的位置，特殊字符.写成\\.以及\\写成\\\\就当作普通字符来匹配 () 将正则表达式的一部分括起来组成一个单元，可以对整个单元使用数量限定符 ([0-9]{1,3}\\.){3}[0-9]{1,3}匹配IP地址 | 连接两个子表达式，表示或的关系 n(o | either)匹配no或neither 以上介绍的是grep正则表达式的Extended规范，Basic规范也有这些语法，只是字符?+{}|()应解释为普通字符，要表示上述特殊含义则需要加\\转义。如果用grep而不是egrep，并且不加-E参数，则应该遵照Basic规范来写正则表达式。 Javascript正则表达式常用正则表达式 匹配中文字符的正则表达式：[\\u4e00-\\u9fa5] 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff] 匹配空白行的正则表达式：\\n\\s*\\r 匹配HTML标记的正则表达式：&amp;lt;(\\S*?)[^&amp;gt;]*&amp;gt;.*?&amp;lt;/\\1&amp;gt;|&amp;lt;.*? /&amp;gt; 匹配首尾空白字符的正则表达式：^\\s*|\\s*$ 匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 匹配网址URL的正则表达式：[a-zA-z]+://[^\\s]* 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 匹配国内电话号码：\\d{3}-\\d{8}|\\d{4}-\\d{7} 匹配腾讯QQ号：[1-9][0-9]{4,} 匹配中国邮政编码：[1-9]\\d{5}(?!\\d) 匹配身份证：\\d{15}|\\d{18} 匹配ip地址：\\d+\\.\\d+\\.\\d+\\.\\d+ 匹配特定数字： 表达式 说明 ^[1-9]\\d*$ 匹配正整数 ^-[1-9]\\d*$ 匹配负整数 ^-?[1-9]\\d*$ 匹配整数 ^[1-9]\\d*|0$ 匹配非负整数（正整数 + 0） ^-[1-9]\\d*|0$ 匹配非正整数（负整数 + 0） ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 匹配正浮点数 ^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 匹配负浮点数 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 匹配浮点数 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 匹配非负浮点数（正浮点数 + 0） ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 匹配非正浮点数（负浮点数 + 0） 匹配特定字符串： 表达式 说明 ^[A-Za-z]+$ 匹配由26个英文字母组成的字符串 ^[A-Z]+$ 匹配由26个英文字母的大写组成的字符串 ^[a-z]+$ 匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$ 匹配由数字和26个英文字母组成的字符串 ^\\w+$ 匹配由数字、26个英文字母或者下划线组成的字符串 深入阅读 regex(7) 常用正则式 工具 regexpbuilderjs：一个使用链式法则推导正则表达式的工具； regexper.com：一个可视化 Javascript 正则表达式的网站。","categories":[{"name":"技术文档","slug":"技术文档","permalink":"https://syhyz1990.github.io/categories/技术文档/"}],"tags":[{"name":"正则,JS","slug":"正则-JS","permalink":"https://syhyz1990.github.io/tags/正则-JS/"}]},{"title":"Vue 编码规范","slug":"vue-standard","date":"2018-06-01T02:41:05.000Z","updated":"2018-06-06T08:46:02.754Z","comments":true,"path":"wiki/vue-standard.html","link":"","permalink":"https://syhyz1990.github.io/wiki/vue-standard.html","excerpt":"","text":"1 目录结构1234567891011121314151617181920212223242526272829config --- 配置文件：配置开发环境代理Api等，自动根据环境打包dist --- 打包文件目录node_modules --- 模块依赖：开发时请勿提交svn，忽略此文件夹src api --- 数据层：接口统一封装到此文件夹下 base --- 基础组件，如轮播图，加载等 assets --- 静态资源文件 css js --- 存放外部JS插件，如jQuery images scss components --- 项目组件：各自按模块进行开发 router --- 路由目录，存放页面跳转路由文件 store --- store仓库：按模块管理各自的vue数据状态 utils --- 工具层：专门封装可复用的函数或方法 2 Vue属性书写顺序1234567891011121314export default &#123; mixins, data, props, store, computed, route, created, ready, // =&gt; 生命周期顺序不赘述 event, watch, components, methods&#125; 3 组件3.1 命名组件以驼峰命名 123456789101112&lt;template&gt; &lt;my-components&gt;&lt;/my-components&gt;&lt;/template&gt;&lt;script&gt; import myComponents from './myComponents.vue' export default &#123; components: &#123; myComponents &#125; &#125;&lt;/script&gt; 3.2 Vue组件的书写顺序建议：template script style 的顺序书写123&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.3 组件引用123456789101112import myComponentsA from './myComponentsA.vue' import myComponentsB from './myComponentsB.vue'import myComponentsC from './myComponentsC.vue'import myComponentsD from './myComponentsD.vue'export default &#123; components: &#123; myComponentsA, myComponentsB, myComponentsC, myComponentsD, &#125;&#125; 4 事件12345&lt;!-- bad --&gt;&lt;a v-on:click=\"pass()\"&gt;pass&lt;/a&gt;&lt;!-- good --&gt;&lt;a @click=\"pass\"&gt;pass&lt;/a&gt;","categories":[{"name":"前端规范","slug":"前端规范","permalink":"https://syhyz1990.github.io/categories/前端规范/"}],"tags":[]},{"title":"CSS / Sass 指南","slug":"scss-standard","date":"2018-05-31T12:29:44.000Z","updated":"2018-06-05T08:23:06.551Z","comments":true,"path":"wiki/scss-standard.html","link":"","permalink":"https://syhyz1990.github.io/wiki/scss-standard.html","excerpt":"","text":"用更合理的方式写 CSS 和 Sass 目录 术语 规则声明 选择器 属性 CSS 格式 注释 OOCSS 和 BEM ID 选择器 JavaScript 钩子 边框 Sass 语法 排序 变量 Mixins 扩展指令 嵌套选择器 术语 规则声明我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子： 1234.listing &#123; font-size: 18px; line-height: 1.2;&#125; 选择器在规则声明中，“选择器” 负责选取 DOM 树中的元素，这些元素将被定义的属性所修饰。选择器可以匹配 HTML 元素，也可以匹配一个元素的类名、ID, 或者元素拥有的属性。以下是选择器的例子： 1234567.my-element-class &#123; /* ... */&#125;[aria-hidden] &#123; /* ... */&#125; 属性最后，属性决定了规则声明里被选择的元素将得到何种样式。属性以键值对形式存在，一个规则声明可以包含一或多个属性定义。以下是属性定义的例子： 1234/* some selector */ &#123; background: #f1f1f1; color: #333;&#125; CSS 格式 使用 2 个空格作为缩进。 类名建议使用破折号代替驼峰法。如果你使用 BEM，也可以使用下划线（参见下面的 OOCSS 和 BEM）。 不要使用 ID 选择器。 在一个规则声明中应用了多个选择器时，每个选择器独占一行。 在规则声明的左大括号 { 前加上一个空格。 在属性的冒号 : 后面加上一个空格，前面不加空格。 规则声明的右大括号 } 独占一行。 规则声明之间用空行分隔开。 Bad 123456789.avatar&#123; border-radius:50%; border:2px solid white; &#125;.no, .nope, .not_good &#123; // ...&#125;#lol-no &#123; // ...&#125; Good 12345678910.avatar &#123; border-radius: 50%; border: 2px solid white;&#125;.one,.selector,.per-line &#123; // ...&#125; 注释 建议使用行注释 (在 Sass 中是 //) 代替块注释。 建议注释独占一行。避免行末注释。 给没有自注释的代码写上详细说明，比如： 为什么用到了 z-index 兼容性处理或者针对特定浏览器的 hack OOCSS 和 BEM出于以下原因，我们鼓励使用 OOCSS 和 BEM 的某种组合： 可以帮助我们理清 CSS 和 HTML 之间清晰且严谨的关系。 可以帮助我们创建出可重用、易装配的组件。 可以减少嵌套，降低特定性。 可以帮助我们创建出可扩展的样式表。 OOCSS，也就是 “Object Oriented CSS（面向对象的CSS）”，是一种写 CSS 的方法，其思想就是鼓励你把样式表看作“对象”的集合：创建可重用性、可重复性的代码段让你可以在整个网站中多次使用。 参考资料： Nicole Sullivan 的 OOCSS wiki Smashing Magazine 的 Introduction to OOCSS BEM，也就是 “Block-Element-Modifier”，是一种用于 HTML 和 CSS 类名的命名约定。BEM 最初是由 Yandex 提出的，要知道他们拥有巨大的代码库和可伸缩性，BEM 就是为此而生的，并且可以作为一套遵循 OOCSS 的参考指导规范。 CSS Trick 的 BEM 101 Harry Roberts 的 introduction to BEM 示例 123456789&lt;article class=\"listing-card listing-card--featured\"&gt; &lt;h1 class=\"listing-card__title\"&gt;Adorable 2BR in the sunny Mission&lt;/h1&gt; &lt;div class=\"listing-card__content\"&gt; &lt;p&gt;Vestibulum id ligula porta felis euismod semper.&lt;/p&gt; &lt;/div&gt;&lt;/article&gt; 1234.listing-card &#123; &#125;.listing-card--featured &#123; &#125;.listing-card__title &#123; &#125;.listing-card__content &#123; &#125; .listing-card 是一个块（block），表示高层次的组件。 .listing-card__title 是一个元素（element），它属于 .listing-card 的一部分，因此块是由元素组成的。 .listing-card--featured 是一个修饰符（modifier），表示这个块与 .listing-card 有着不同的状态或者变化。 ID 选择器在 CSS 中，虽然可以通过 ID 选择元素，但大家通常都会把这种方式列为反面教材。ID 选择器给你的规则声明带来了不必要的高优先级，而且 ID 选择器是不可重用的。 想要了解关于这个主题的更多内容，参见 CSS Wizardry 的文章，文章中有关于如何处理优先级的内容。 JavaScript 钩子避免在 CSS 和 JavaScript 中绑定相同的类。否则开发者在重构时通常会出现以下情况：轻则浪费时间在对照查找每个要改变的类，重则因为害怕破坏功能而不敢作出更改。 我们推荐在创建用于特定 JavaScript 的类名时，添加 .js- 前缀： 1&lt;button class=\"btn btn-primary js-request-to-book\"&gt;Request to Book&lt;/button&gt; 边框在定义无边框样式时，使用 0 代替 none。 Bad 123.foo &#123; border: none;&#125; Good 123.foo &#123; border: 0;&#125; Sass 语法 使用 .scss 的语法，不使用 .sass 原本的语法。 CSS 和 @include 声明按照以下逻辑排序（参见下文） 属性声明的排序 属性声明 首先列出除去 @include 和嵌套选择器之外的所有属性声明。 12345.btn-green &#123; background: green; font-weight: bold; // ...&#125; @include 声明 紧随后面的是 @include，这样可以使得整个选择器的可读性更高。 123456.btn-green &#123; background: green; font-weight: bold; @include transition(background 0.5s ease); // ...&#125; 嵌套选择器 如果有必要用到嵌套选择器，把它们放到最后，在规则声明和嵌套选择器之间要加上空白，相邻嵌套选择器之间也要加上空白。嵌套选择器中的内容也要遵循上述指引。 123456789.btn &#123; background: green; font-weight: bold; @include transition(background 0.5s ease); .icon &#123; margin-right: 10px; &#125;&#125; 变量变量名应使用破折号（例如 $my-variable）代替 camelCased 和 snake_cased 风格。对于仅用在当前文件的变量，可以在变量名之前添加下划线前缀（例如 $_my-variable）。 Mixins为了让代码遵循 DRY 原则（Don’t Repeat Yourself）、增强清晰性或抽象化复杂性，应该使用 mixin，这与那些命名良好的函数的作用是异曲同工的。虽然 mixin 可以不接收参数，但要注意，假如你不压缩负载（比如通过 gzip），这样会导致最终的样式包含不必要的代码重复。 扩展指令应避免使用 @extend 指令，因为它并不直观，而且具有潜在风险，特别是用在嵌套选择器的时候。即便是在顶层占位符选择器使用扩展，如果选择器的顺序最终会改变，也可能会导致问题。（比如，如果它们存在于其他文件，而加载顺序发生了变化）。其实，使用 @extend 所获得的大部分优化效果，gzip 压缩已经帮助你做到了，因此你只需要通过 mixin 让样式表更符合 DRY 原则就足够了。 嵌套选择器请不要让嵌套选择器的深度超过 3 层！ 1234567.page-container &#123; .content &#123; .profile &#123; // STOP! &#125; &#125;&#125; 当遇到以上情况的时候，你也许是这样写 CSS 的： 与 HTML 强耦合的（也是脆弱的）—或者— 过于具体（强大）—或者— 没有重用 再说一遍: 永远不要嵌套 ID 选择器！ 如果你始终坚持要使用 ID 选择器（劝你三思），那也不应该嵌套它们。如果你正打算这么做，你需要先重新检查你的标签，或者指明原因。如果你想要写出风格良好的 HTML 和 CSS，你是不应该这样做的。","categories":[{"name":"前端规范","slug":"前端规范","permalink":"https://syhyz1990.github.io/categories/前端规范/"}],"tags":[{"name":"CSS,SCSS","slug":"CSS-SCSS","permalink":"https://syhyz1990.github.io/tags/CSS-SCSS/"}]},{"title":"JS判断数据类型","slug":"js-type-judgment","date":"2018-05-25T11:24:11.000Z","updated":"2018-06-05T08:23:06.586Z","comments":true,"path":"wiki/js-type-judgment.html","link":"","permalink":"https://syhyz1990.github.io/wiki/js-type-judgment.html","excerpt":"","text":"判断数据类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145 /** * 判断 Array 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is an Array, otherwise false */function isArray(val) &#123; return toString.call(val) === '[object Array]';&#125;/** * 判断 ArrayBuffer 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is an ArrayBuffer, otherwise false */function isArrayBuffer(val) &#123; return toString.call(val) === '[object ArrayBuffer]';&#125;/** * 判断 FormData 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is an FormData, otherwise false */function isFormData(val) &#123; return (typeof FormData !== 'undefined') &amp;&amp; (val instanceof FormData);&#125;/** * 判断 ArrayBuffer 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is a view on an ArrayBuffer, otherwise false */function isArrayBufferView(val) &#123; var result; if ((typeof ArrayBuffer !== 'undefined') &amp;&amp; (ArrayBuffer.isView)) &#123; result = ArrayBuffer.isView(val); &#125; else &#123; result = (val) &amp;&amp; (val.buffer) &amp;&amp; (val.buffer instanceof ArrayBuffer); &#125; return result;&#125;/** * 判断 String 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is a String, otherwise false */function isString(val) &#123; return typeof val === 'string';&#125;/** * 判断 Number 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is a Number, otherwise false */function isNumber(val) &#123; return typeof val === 'number';&#125;/** * 判断 undefined 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if the value is undefined, otherwise false */function isUndefined(val) &#123; return typeof val === 'undefined';&#125;/** * 判断 Object 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is an Object, otherwise false */function isObject(val) &#123; return val !== null &amp;&amp; typeof val === 'object';&#125;/** * 判断 Date 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is a Date, otherwise false */function isDate(val) &#123; return toString.call(val) === '[object Date]';&#125;/** * 判断 File 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is a File, otherwise false */function isFile(val) &#123; return toString.call(val) === '[object File]';&#125;/** * 判断 Blob 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is a Blob, otherwise false */function isBlob(val) &#123; return toString.call(val) === '[object Blob]';&#125;/** * 判断 Function 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is a Function, otherwise false */function isFunction(val) &#123; return toString.call(val) === '[object Function]';&#125;/** * 判断 Stream 类型 * * @param &#123;Object&#125; val The value to test * @returns &#123;boolean&#125; True if value is a Stream, otherwise false */function isStream(val) &#123; return isObject(val) &amp;&amp; isFunction(val.pipe);&#125;/** * 去掉字符串首尾空格 * * @param &#123;String&#125; str The String to trim * @returns &#123;String&#125; The String freed of excess whitespace */function trim(str) &#123; return str.replace(/^\\s*/, '').replace(/\\s*$/, '');&#125;","categories":[{"name":"代码片段","slug":"代码片段","permalink":"https://syhyz1990.github.io/categories/代码片段/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://syhyz1990.github.io/tags/JS/"}]},{"title":"ECMAScript6 前端规范","slug":"ecmascript6-standard","date":"2018-05-25T08:24:19.000Z","updated":"2018-06-05T08:23:06.562Z","comments":true,"path":"wiki/ecmascript6-standard.html","link":"","permalink":"https://syhyz1990.github.io/wiki/ecmascript6-standard.html","excerpt":"","text":"用更合理的方式写 JavaScript 目录 类型 引用 对象 数组 解构 字符串 函数 箭头函数 构造函数 模块 迭代器和生成器 属性 变量 提升 比较运算符和等号 代码块 注释 空白 逗号 分号 类型转换 命名规则 存取器 事件 jQuery ECMAScript 5 兼容性 ECMAScript 6 编码规范 类型 1.1 基本类型: 直接存取基本类型。 字符串 数值 布尔类型 null undefined 123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 1.2 复杂类型: 通过引用的方式存取复杂类型。 对象 数组 函数 123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 ⬆ 返回目录 引用 2.1 对所有的引用使用 const ；不要使用 var。 为什么？这能确保你无法对引用重新赋值，也不会导致出现 bug 或难以理解。 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; 2.2 如果你一定需要可变动的引用，使用 let 代替 var。 为什么？因为 let 是块级作用域，而 var 是函数作用域。 1234567891011// badvar count = 1;if (true) &#123; count += 1;&#125;// good, use the let.let count = 1;if (true) &#123; count += 1;&#125; 2.3 注意 let 和 const 都是块级作用域。 1234567// const 和 let 只存在于它们被定义的区块内。&#123; let a = 1; const b = 1;&#125;console.log(a); // ReferenceErrorconsole.log(b); // ReferenceError ⬆ 返回目录 对象 3.1 使用字面值创建对象。 12345// badconst item = new Object();// goodconst item = &#123;&#125;; 3.2 如果你的代码在浏览器环境下执行，别使用 保留字 作为键值。这样的话在 IE8 不会运行。 更多信息。 但在 ES6 模块和服务器端中使用没有问题。 1234567891011// badconst superman = &#123; default: &#123; clark: 'kent' &#125;, private: true,&#125;;// goodconst superman = &#123; defaults: &#123; clark: 'kent' &#125;, hidden: true,&#125;; 3.3 使用同义词替换需要使用的保留字。 1234567891011121314// badconst superman = &#123; class: 'alien',&#125;;// badconst superman = &#123; klass: 'alien',&#125;;// goodconst superman = &#123; type: 'alien',&#125;; 3.4 创建有动态属性名的对象时，使用可被计算的属性名称。 为什么？因为这样可以让你在一个地方定义所有的对象属性。 1234567891011121314151617function getKey(k) &#123; return `a key named $&#123;k&#125;`;&#125;// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; 3.5 使用对象方法的简写。 1234567891011121314151617// badconst atom = &#123; value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 3.6 使用对象属性值的简写。 为什么？因为这样更短更有描述性。 1234567891011const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; lukeSkywalker: lukeSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker,&#125;; 3.7 在对象属性声明前把简写的属性分组。 为什么？因为这样能清楚地看出哪些属性使用了简写。 12345678910111213141516171819202122const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; episodeOne: 1, twoJedisWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJedisWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4,&#125;; ⬆ 返回目录 数组 4.1 使用字面值创建数组。 12345// badconst items = new Array();// goodconst items = []; 4.2 向数组添加元素时使用 Arrary#push 替代直接赋值。 12345678const someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); 4.3 使用拓展运算符 ... 复制数组。 123456789101112131415// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items];// 数组深拷贝 ES5let arr = [1,2,3,4,5];let arr2 = arr.concat(); 4.4 使用 Array#from 把一个类数组对象转换成数组。 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); ⬆ 返回目录 解构 5.1 使用解构存取和使用多属性对象。 为什么？因为解构能减少临时引用属性。 123456789101112131415161718// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; 5.2 对数组使用解构赋值。 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 5.3 需要回传多个值时，使用对象解构，而不是数组解构。 为什么？增加属性或者改变排序不会改变调用时的位置。 1234567891011121314151617// badfunction processInput(input) &#123; // then a miracle occurs return [left, right, top, bottom];&#125;// 调用时需要考虑回调数据的顺序。const [left, __, top] = processInput(input);// goodfunction processInput(input) &#123; // then a miracle occurs return &#123; left, right, top, bottom &#125;;&#125;// 调用时只选择需要的数据const &#123; left, right &#125; = processInput(input); ⬆ 返回目录 Strings 6.1 字符串使用单引号 &#39;&#39; 。 12345// badconst name = \"Capt. Janeway\";// goodconst name = 'Capt. Janeway'; 6.2 字符串超过 80 个字节应该使用字符串连接号换行。 6.3 注：过度使用字串连接符号可能会对性能造成影响。jsPerf 和 讨论. 12345678910111213// badconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';// badconst errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// goodconst errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.'; 6.4 程序化生成字符串时，使用模板字符串代替字符串连接。 为什么？模板字符串更为简洁，更具可读性。 1234567891011121314// badfunction sayHi(name) &#123; return 'How are you, ' + name + '?';&#125;// badfunction sayHi(name) &#123; return ['How are you, ', name, '?'].join();&#125;// goodfunction sayHi(name) &#123; return `How are you, $&#123;name&#125;?`;&#125; ⬆ 返回目录 函数 7.1 使用函数声明代替函数表达式。 为什么？因为函数声明是可命名的，所以他们在调用栈中更容易被识别。此外，函数声明会把整个函数提升（hoisted），而函数表达式只会把函数的引用变量名提升。这条规则使得箭头函数可以取代函数表达式。 1234567// badconst foo = function () &#123;&#125;;// goodfunction foo() &#123;&#125; 7.2 函数表达式: 1234// 立即调用的函数表达式 (IIFE)(() =&gt; &#123; console.log('Welcome to the Internet. Please follow me.');&#125;)(); 7.3 永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。 7.4 注意: ECMA-262 把 block 定义为一组语句。函数声明不是语句。阅读 ECMA-262 关于这个问题的说明。 1234567891011121314// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125;// goodlet test;if (currentUser) &#123; test = () =&gt; &#123; console.log('Yup.'); &#125;;&#125; 7.5 永远不要把参数命名为 arguments。这将取代原来函数作用域内的 arguments 对象。 123456789// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125;// goodfunction yup(name, options, args) &#123; // ...stuff...&#125; 7.6 不要使用 arguments。可以选择 rest 语法 ... 替代。 为什么？使用 ... 能明确你要传入的参数。另外 rest 参数是一个真正的数组，而 arguments 是一个类数组。 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join('');&#125;// goodfunction concatenateAll(...args) &#123; return args.join('');&#125; 7.7 直接给函数的参数指定默认值，不要使用一个变化的函数参数。 12345678910111213141516171819202122// really badfunction handleThings(opts) &#123; // 不！我们不应该改变函数参数。 // 更加糟糕: 如果参数 opts 是 false 的话，它就会被设定为一个对象。 // 但这样的写法会造成一些 Bugs。 //（译注：例如当 opts 被赋值为空字符串，opts 仍然会被下一行代码设定为一个空对象。） opts = opts || &#123;&#125;; // ...&#125;// still badfunction handleThings(opts) &#123; if (opts === void 0) &#123; opts = &#123;&#125;; &#125; // ...&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 7.8 直接给函数参数赋值时需要避免副作用。 为什么？因为这样的写法让人感到很困惑。 123456789var b = 1;// badfunction count(a = b++) &#123; console.log(a);&#125;count(); // 1count(); // 2count(3); // 3count(); // 3 ⬆ 返回目录 箭头函数 8.1 当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。 为什么？因为箭头函数创造了新的一个 this 执行环境（译注：参考 Arrow functions - JavaScript | MDN 和 ES6 arrow functions, syntax and lexical scoping），通常情况下都能满足你的需求，而且这样的写法更为简洁。 为什么不？如果你有一个相当复杂的函数，你或许可以把逻辑部分转移到一个函数声明上。 1234567891011// bad[1, 2, 3].map(function (x) &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;); 8.2 如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 return 都省略掉。如果不是，那就不要省略。 为什么？语法糖。在链式调用中可读性很高。 为什么不？当你打算回传一个对象的时候。 1234567// good[1, 2, 3].map(x =&gt; x * x);// good[1, 2, 3].reduce((total, n) =&gt; &#123; return total + n;&#125;, 0); ⬆ 返回目录 构造器 9.1 总是使用 class。避免直接操作 prototype 。 为什么? 因为 class 语法更为简洁更易读。 12345678910111213141516171819202122// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 9.2 使用 extends 继承。 为什么？因为 extends 是一个内建的原型继承方法并且不会破坏 instanceof。 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 9.3 方法可以返回 this 来帮助链式调用。 12345678910111213141516171819202122232425262728293031// badJedi.prototype.jump = function() &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function(height) &#123; this.height = height;&#125;;const luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodclass Jedi &#123; jump() &#123; this.jumping = true; return this; &#125; setHeight(height) &#123; this.height = height; return this; &#125;&#125;const luke = new Jedi();luke.jump() .setHeight(20); 9.4 可以写一个自定义的 toString() 方法，但要确保它能正常运行并且不会引起副作用。 12345678910111213class Jedi &#123; constructor(options = &#123;&#125;) &#123; this.name = options.name || 'no name'; &#125; getName() &#123; return this.name; &#125; toString() &#123; return `Jedi - $&#123;this.getName()&#125;`; &#125;&#125; ⬆ 返回目录 模块 10.1 总是使用模组 (import/export) 而不是其他非标准模块系统。你可以编译为你喜欢的模块系统。 为什么？模块就是未来，让我们开始迈向未来吧。 1234567891011// badconst AirbnbStyleGuide = require('./AirbnbStyleGuide');module.exports = AirbnbStyleGuide.es6;// okimport AirbnbStyleGuide from './AirbnbStyleGuide';export default AirbnbStyleGuide.es6;// bestimport &#123; es6 &#125; from './AirbnbStyleGuide';export default es6; 10.2 不要使用通配符 import。 为什么？这样能确保你只有一个默认 export。 12345// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide'; 10.3 不要从 import 中直接 export。 为什么？虽然一行代码简洁明了，但让 import 和 export 各司其职让事情能保持一致。 12345678// bad// filename es6.jsexport &#123; es6 as default &#125; from './airbnbStyleGuide';// good// filename es6.jsimport &#123; es6 &#125; from './AirbnbStyleGuide';export default es6; ⬆ 返回目录 Iterators and Generators 11.1 不要使用 iterators。使用高阶函数例如 map() 和 reduce() 替代 for-of。 为什么？这加强了我们不变的规则。处理纯函数的回调值更易读，这比它带来的副作用更重要。 123456789101112131415161718const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) &#123; sum += num;&#125;sum === 15;// goodlet sum = 0;numbers.forEach((num) =&gt; sum += num);sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15; 11.2 现在还不要使用 generators。 为什么？因为它们现在还没法很好地编译到 ES5。 (译者注：目前(2016/03) Chrome 和 Node.js 的稳定版本都已支持 generators) ⬆ 返回目录 属性 12.1 使用 . 来访问对象的属性。 12345678910const luke = &#123; jedi: true, age: 28,&#125;;// badconst isJedi = luke['jedi'];// goodconst isJedi = luke.jedi; 12.2 当通过变量访问属性时使用中括号 []。 12345678910const luke = &#123; jedi: true, age: 28,&#125;;function getProp(prop) &#123; return luke[prop];&#125;const isJedi = getProp('jedi'); ⬆ 返回目录 变量 13.1 一直使用 const 来声明变量，如果不这样做就会产生全局变量。我们需要避免全局命名空间的污染。地球队长已经警告过我们了。（译注：全局，global 亦有全球的意思。地球队长的责任是保卫地球环境，所以他警告我们不要造成「全球」污染。） 12345// badsuperPower = new SuperPower();// goodconst superPower = new SuperPower(); 13.2 使用 const 声明每一个变量。 为什么？增加新变量将变的更加容易，而且你永远不用再担心调换错 ; 跟 ,。 123456789101112131415// badconst items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// (compare to above, and try to spot the mistake)const items = getItems(), goSportsTeam = true; dragonball = 'z';// goodconst items = getItems();const goSportsTeam = true;const dragonball = 'z'; 13.3 将所有的 const 和 let 分组 为什么？当你需要把已赋值变量赋值给未赋值变量时非常有用。 123456789101112131415161718// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; 13.4 在你需要的地方给变量赋值，但请把它们放在一个合理的位置。 为什么？let 和 const 是块级作用域而不是函数作用域。 12345678910111213141516171819202122232425262728293031323334353637383940// goodfunction() &#123; test(); console.log('doing stuff..'); //..other stuff.. const name = getName(); if (name === 'test') &#123; return false; &#125; return name;&#125;// bad - unnecessary function callfunction(hasName) &#123; const name = getName(); if (!hasName) &#123; return false; &#125; this.setFirstName(name); return true;&#125;// goodfunction(hasName) &#123; if (!hasName) &#123; return false; &#125; const name = getName(); this.setFirstName(name); return true;&#125; ⬆ 返回目录 提升 14.1 var 声明会被提升至该作用域的顶部，但它们赋值不会提升。let 和 const 被赋予了一种称为「暂时性死区（Temporal Dead Zones, TDZ）」的概念。这对于了解为什么 type of 不再安全相当重要。 12345678910111213141516171819202122232425262728// 我们知道这样运行不了// （假设 notDefined 不是全局变量）function example() &#123; console.log(notDefined); // =&gt; throws a ReferenceError&#125;// 由于变量提升的原因，// 在引用变量后再声明变量是可以运行的。// 注：变量的赋值 `true` 不会被提升。function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// 编译器会把函数声明提升到作用域的顶层，// 这意味着我们的例子可以改写成这样：function example() &#123; let declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125;// 使用 const 和 letfunction example() &#123; console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError const declaredButNotAssigned = true;&#125; 14.2 匿名函数表达式的变量名会被提升，但函数内容并不会。 123456789function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function() &#123; console.log('anonymous function expression'); &#125;;&#125; 14.3 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会。 1234567891011121314151617181920212223function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() &#123; console.log('Flying'); &#125;;&#125;// the same is true when the function name// is the same as the variable name.function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() &#123; console.log('named'); &#125;&#125; 14.4 函数声明的名称和函数体都会被提升。 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125; 想了解更多信息，参考 Ben Cherry 的 JavaScript Scoping &amp; Hoisting。 ⬆ 返回目录 比较运算符和等号 15.1 优先使用 === 和 !== 而不是 == 和 !=. 15.2 条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则： 对象 被计算为 true Undefined 被计算为 false Null 被计算为 false 布尔值 被计算为 布尔的值 数字 如果是 +0、-0、或 NaN 被计算为 false, 否则为 true 字符串 如果是空字符串 &#39;&#39; 被计算为 false，否则为 true 1234if ([0]) &#123; // true // An array is an object, objects evaluate to true&#125; 15.3 使用简写。 12345678910111213141516171819// badif (name !== '') &#123; // ...stuff...&#125;// goodif (name) &#123; // ...stuff...&#125;// badif (collection.length &gt; 0) &#123; // ...stuff...&#125;// goodif (collection.length) &#123; // ...stuff...&#125; 15.4 想了解更多信息，参考 Angus Croll 的 Truth Equality and JavaScript。 ⬆ 返回目录 代码块 16.1 使用大括号包裹所有的多行代码块。 12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction() &#123; return false; &#125;// goodfunction() &#123; return false;&#125; 16.2 如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。 12345678910111213141516// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125;// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125; ⬆ 返回目录 注释 17.1 使用 /** ... */ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。 123456789101112131415161718192021222324252627// bad// make() returns a new element// based on the passed in tag name//// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// good/** * make() returns a new element * based on the passed in tag name * * @param &#123;String&#125; tag * @return &#123;Element&#125; element */function make(tag) &#123; // ...stuff... return element;&#125; 17.2 使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。 12345678910111213141516171819202122232425// badconst active = true; // is current tab// good// is current tabconst active = true;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125;// goodfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125; 17.3 给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME -- need to figure this out 或者 TODO -- need to implement。 17.4 使用 // FIXME: 标注问题。 123456class Calculator &#123; constructor() &#123; // FIXME: shouldn't use a global here total = 0; &#125;&#125; 17.5 使用 // TODO: 标注问题的解决方式。 123456class Calculator &#123; constructor() &#123; // TODO: total should be configurable by an options param this.total = 0; &#125;&#125; ⬆ 返回目录 空白 18.1 使用 2 个空格作为缩进。 1234567891011121314// badfunction() &#123;∙∙∙∙const name;&#125;// badfunction() &#123;∙const name;&#125;// goodfunction() &#123;∙∙const name;&#125; 18.2 在花括号前放一个空格。 123456789101112131415161718192021// badfunction test()&#123; console.log('test');&#125;// goodfunction test() &#123; console.log('test');&#125;// baddog.set('attr',&#123; age: '1 year', breed: 'Bernese Mountain Dog',&#125;);// gooddog.set('attr', &#123; age: '1 year', breed: 'Bernese Mountain Dog',&#125;); 18.3 在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。 12345678910111213141516171819// badif(isJedi) &#123; fight ();&#125;// goodif (isJedi) &#123; fight();&#125;// badfunction fight () &#123; console.log ('Swooosh!');&#125;// goodfunction fight() &#123; console.log('Swooosh!');&#125; 18.4 使用空格把运算符隔开。 12345// badconst x=y+5;// goodconst x = y + 5; 18.5 在文件末尾插入一个空行。 1234// bad(function(global) &#123; // ...stuff...&#125;)(this); 12345// bad(function(global) &#123; // ...stuff...&#125;)(this);↵↵ 1234// good(function(global) &#123; // ...stuff...&#125;)(this);↵ 18.5 在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。 12345678910111213141516171819202122232425262728293031323334// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badconst leds = stage.selectAll('.led').data(data).enter().append('svg:svg').class('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);// goodconst leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); 18.6 在块末和新语句前插入空行。 1234567891011121314151617181920212223242526272829303132// badif (foo) &#123; return bar;&#125;return baz;// goodif (foo) &#123; return bar;&#125;return baz;// badconst obj = &#123; foo() &#123; &#125;, bar() &#123; &#125;,&#125;;return obj;// goodconst obj = &#123; foo() &#123; &#125;, bar() &#123; &#125;,&#125;;return obj; ⬆ 返回目录 逗号 19.1 行首逗号：不需要。 1234567891011121314151617181920212223242526272829// badconst story = [ once , upon , aTime];// goodconst story = [ once, upon, aTime,];// badconst hero = &#123; firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers'&#125;;// goodconst hero = &#123; firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers',&#125;; 19.2 增加结尾的逗号: 需要。 为什么? 这会让 git diffs 更干净。另外，像 babel 这样的转译器会移除结尾多余的逗号，也就是说你不必担心老旧浏览器的尾逗号问题。 123456789101112131415161718192021222324252627282930313233343536// bad - git diff without trailing commaconst hero = &#123; firstName: 'Florence',- lastName: 'Nightingale'+ lastName: 'Nightingale',+ inventorOf: ['coxcomb graph', 'modern nursing']&#125;// good - git diff with trailing commaconst hero = &#123; firstName: 'Florence', lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing'],&#125;// badconst hero = &#123; firstName: 'Dana', lastName: 'Scully'&#125;;const heroes = [ 'Batman', 'Superman'];// goodconst hero = &#123; firstName: 'Dana', lastName: 'Scully',&#125;;const heroes = [ 'Batman', 'Superman',]; ⬆ 返回目录 分号 20.1 使用分号 1234567891011121314151617// bad(function() &#123; const name = 'Skywalker' return name&#125;)()// good(() =&gt; &#123; const name = 'Skywalker'; return name;&#125;)();// good (防止函数在两个 IIFE 合并时被当成一个参数);(() =&gt; &#123; const name = 'Skywalker'; return name;&#125;)(); Read more. ⬆ 返回目录 类型转换 21.1 在语句开始时执行类型转换。 21.2 字符串： 1234567// =&gt; this.reviewScore = 9;// badconst totalScore = this.reviewScore + '';// goodconst totalScore = String(this.reviewScore); 21.3 对数字使用 parseInt 转换，并带上类型转换的基数。 12345678910111213141516171819const inputValue = '4';// badconst val = new Number(inputValue);// badconst val = +inputValue;// badconst val = inputValue &gt;&gt; 0;// badconst val = parseInt(inputValue);// goodconst val = Number(inputValue);// goodconst val = parseInt(inputValue, 10); 21.4 如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。 123456// good/** * 使用 parseInt 导致我的程序变慢， * 改成使用位操作转换数字快多了。 */const val = inputValue &gt;&gt; 0; 21.5 注: 小心使用位操作运算符。数字会被当成 64 位值，但是位操作运算符总是返回 32 位的整数（参考）。位操作处理大于 32 位的整数值时还会导致意料之外的行为。关于这个问题的讨论。最大的 32 位整数是 2,147,483,647： 1232147483647 &gt;&gt; 0 //=&gt; 21474836472147483648 &gt;&gt; 0 //=&gt; -21474836482147483649 &gt;&gt; 0 //=&gt; -2147483647 21.6 布尔: 12345678910const age = 0;// badconst hasAge = new Boolean(age);// goodconst hasAge = Boolean(age);// goodconst hasAge = !!age; ⬆ 返回目录 命名规则 22.1 避免单字母命名。命名应具备描述性。 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 22.2 使用驼峰式命名对象、函数和实例。 12345678// badconst OBJEcttsssss = &#123;&#125;;const this_is_my_object = &#123;&#125;;function c() &#123;&#125;// goodconst thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125; 22.3 使用帕斯卡式命名构造函数或类。 12345678910111213141516171819// badfunction user(options) &#123; this.name = options.name;&#125;const bad = new user(&#123; name: 'nope',&#125;);// goodclass User &#123; constructor(options) &#123; this.name = options.name; &#125;&#125;const good = new User(&#123; name: 'yup',&#125;); 22.4 不要使用下划线 _ 结尾或开头来命名属性和方法。 1234567// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda'; 22.5 别保存 this 的引用。使用箭头函数或 Function#bind。 12345678910111213141516171819202122// badfunction foo() &#123; const self = this; return function() &#123; console.log(self); &#125;;&#125;// badfunction foo() &#123; const that = this; return function() &#123; console.log(that); &#125;;&#125;// goodfunction foo() &#123; return () =&gt; &#123; console.log(this); &#125;;&#125; 22.6 如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。 123456789101112131415// file contentsclass CheckBox &#123; // ...&#125;export default CheckBox;// in some other file// badimport CheckBox from './checkBox';// badimport CheckBox from './check_box';// goodimport CheckBox from './CheckBox'; 22.7 当你导出默认的函数时使用驼峰式命名。你的文件名必须和函数名完全保持一致。 1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 22.8 当你导出单例、函数库、空对象时使用帕斯卡式命名。 123456const AirbnbStyleGuide = &#123; es6: &#123; &#125;&#125;;export default AirbnbStyleGuide; ⬆ 返回目录 存取器 23.1 属性的存取函数不是必须的。 23.2 如果你需要存取函数时使用 getVal() 和 setVal(&#39;hello&#39;)。 1234567891011// baddragon.age();// gooddragon.getAge();// baddragon.age(25);// gooddragon.setAge(25); 23.3 如果属性是布尔值，使用 isVal() 或 hasVal()。 123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; 23.4 创建 get() 和 set() 函数是可以的，但要保持一致。 1234567891011121314class Jedi &#123; constructor(options = &#123;&#125;) &#123; const lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber); &#125; set(key, val) &#123; this[key] = val; &#125; get(key) &#123; return this[key]; &#125;&#125; ⬆ 返回目录 事件 24.1 当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法： 12345678// bad$(this).trigger('listingUpdated', listing.id);...$(this).on('listingUpdated', function(e, listingId) &#123; // do something with listingId&#125;); 更好的写法： 12345678// good$(this).trigger('listingUpdated', &#123; listingId : listing.id &#125;);...$(this).on('listingUpdated', function(e, data) &#123; // do something with data.listingId&#125;); ⬆ 返回目录 jQuery 25.1 使用 $ 作为存储 jQuery 对象的变量名前缀。 12345// badconst sidebar = $('.sidebar');// goodconst $sidebar = $('.sidebar'); 25.2 缓存 jQuery 查询。 12345678910111213141516171819202122// badfunction setSidebar() &#123; $('.sidebar').hide(); // ...stuff... $('.sidebar').css(&#123; 'background-color': 'pink' &#125;);&#125;// goodfunction setSidebar() &#123; const $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; 'background-color': 'pink' &#125;);&#125; 25.3 对 DOM 查询使用层叠 $(&#39;.sidebar ul&#39;) 或 父元素 &gt; 子元素 $(&#39;.sidebar &gt; ul&#39;)。 jsPerf 25.4 对有作用域的 jQuery 对象查询使用 find。 1234567891011121314// bad$('ul', '.sidebar').hide();// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); ⬆ 返回目录 ECMAScript 5 兼容性 26.1 参考 Kangax 的 ES5 兼容性。 ⬆ 返回目录 ECMAScript 6 规范 27.1 以下是链接到 ES6 各个特性的列表。 箭头函数 类 对象方法简写 对象属性简写 对象中的可计算属性 模板字符串 解构 默认参数 Rest 数组 Spreads Let 及 Const 迭代器和生成器 模块 ⬆ 返回目录 测试 28.1 Yup. 123function() &#123; return true;&#125; ⬆ 返回目录 相关资源（英文）了解 ES6 ECMA 2015 (ES6) 规范草案 ExploringJS ES6 兼容性表 ES6 特性全面概况 ⬆ 返回目录","categories":[{"name":"前端规范","slug":"前端规范","permalink":"https://syhyz1990.github.io/categories/前端规范/"}],"tags":[{"name":"JS,ECMAScript6","slug":"JS-ECMAScript6","permalink":"https://syhyz1990.github.io/tags/JS-ECMAScript6/"}]},{"title":"ECMAScript5 前端规范","slug":"ecmascript5-standard","date":"2018-03-24T11:24:19.000Z","updated":"2018-06-05T08:23:06.540Z","comments":true,"path":"wiki/ecmascript5-standard.html","link":"","permalink":"https://syhyz1990.github.io/wiki/ecmascript5-standard.html","excerpt":"","text":"用更合理的方式写 JavaScript 目录 类型 对象 数组 字符串 函数 属性 变量 提升 比较运算符 &amp; 等号 块 注释 空白 逗号 分号 类型转化 命名规则 存取器 构造函数 事件 模块 jQuery ECMAScript 5 兼容性 测试 类型 原始值: 存取直接作用于它自身。 string number boolean null undefined 123456var foo = 1;var bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 复杂类型: 存取时作用于它自身值的引用。 object array function 123456var foo = [1, 2];var bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 ⬆ 回到顶部 对象 使用直接量创建对象。 12345// badvar item = new Object();// goodvar item = &#123;&#125;; 不要使用保留字作为键名，它们在 IE8 下不工作。更多信息。 1234567891011// badvar superman = &#123; default: &#123; clark: 'kent' &#125;, private: true&#125;;// goodvar superman = &#123; defaults: &#123; clark: 'kent' &#125;, hidden: true&#125;; 使用同义词替换需要使用的保留字。 1234567891011121314// badvar superman = &#123; class: 'alien'&#125;;// badvar superman = &#123; klass: 'alien'&#125;;// goodvar superman = &#123; type: 'alien'&#125;; ⬆ 回到顶部 数组 使用直接量创建数组。 12345// badvar items = new Array();// goodvar items = []; 向数组增加元素时使用 Array#push 来替代直接赋值。 12345678var someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); 当你需要拷贝数组时，使用 Array#slice。jsPerf 1234567891011var len = items.length;var itemsCopy = [];var i;// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// gooditemsCopy = items.slice(); 使用 Array#slice 将类数组对象转换成数组。 1234function trigger() &#123; var args = Array.prototype.slice.call(arguments); ...&#125; ⬆ 回到顶部 字符串 使用单引号 &#39;&#39; 包裹字符串。 1234567891011// badvar name = \"Bob Parr\";// goodvar name = 'Bob Parr';// badvar fullName = \"Bob \" + this.lastName;// goodvar fullName = 'Bob ' + this.lastName; 超过 100 个字符的字符串应该使用连接符写成多行。 注：若过度使用，通过连接符连接的长字符串可能会影响性能。jsPerf &amp; 讨论. 12345678910111213// badvar errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';// badvar errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// goodvar errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.'; 程序化生成的字符串使用 Array#join 连接而不是使用连接符。尤其是 IE 下：jsPerf. 12345678910111213141516171819202122232425262728293031323334353637383940var items;var messages;var length;var i;messages = [&#123; state: 'success', message: 'This one worked.'&#125;, &#123; state: 'success', message: 'This one worked as well.'&#125;, &#123; state: 'error', message: 'This one did not work.'&#125;];length = messages.length;// badfunction inbox(messages) &#123; items = '&lt;ul&gt;'; for (i = 0; i &lt; length; i++) &#123; items += '&lt;li&gt;' + messages[i].message + '&lt;/li&gt;'; &#125; return items + '&lt;/ul&gt;';&#125;// goodfunction inbox(messages) &#123; items = []; for (i = 0; i &lt; length; i++) &#123; // use direct assignment in this case because we're micro-optimizing. items[i] = '&lt;li&gt;' + messages[i].message + '&lt;/li&gt;'; &#125; return '&lt;ul&gt;' + items.join('') + '&lt;/ul&gt;';&#125; ⬆ 回到顶部 函数 函数表达式： 1234567891011121314// 匿名函数表达式var anonymous = function() &#123; return true;&#125;;// 命名函数表达式var named = function named() &#123; return true;&#125;;// 立即调用的函数表达式（IIFE）(function () &#123; console.log('Welcome to the Internet. Please follow me.');&#125;()); 永远不要在一个非函数代码块（if、while 等）中声明一个函数，浏览器允许你这么做，但它们的解析表现不一致，正确的做法是：在块外定义一个变量，然后将函数赋值给它。 注： ECMA-262 把 块 定义为一组语句。函数声明不是语句。阅读对 ECMA-262 这个问题的说明。 1234567891011121314// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125;// goodvar test;if (currentUser) &#123; test = function test() &#123; console.log('Yup.'); &#125;;&#125; 永远不要把参数命名为 arguments。这将取代函数作用域内的 arguments 对象。 123456789// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125;// goodfunction yup(name, options, args) &#123; // ...stuff...&#125; ⬆ 回到顶部 属性 使用 . 来访问对象的属性。 12345678910var luke = &#123; jedi: true, age: 28&#125;;// badvar isJedi = luke['jedi'];// goodvar isJedi = luke.jedi; 当通过变量访问属性时使用中括号 []。 12345678910var luke = &#123; jedi: true, age: 28&#125;;function getProp(prop) &#123; return luke[prop];&#125;var isJedi = getProp('jedi'); ⬆ 回到顶部 变量 总是使用 var 来声明变量。不这么做将导致产生全局变量。我们要避免污染全局命名空间。 12345// badsuperPower = new SuperPower();// goodvar superPower = new SuperPower(); 使用 var 声明每一个变量。这样做的好处是增加新变量将变的更加容易，而且你永远不用再担心调换错 ; 跟 ,。 123456789101112131415// badvar items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// （跟上面的代码比较一下，看看哪里错了）var items = getItems(), goSportsTeam = true; dragonball = 'z';// goodvar items = getItems();var goSportsTeam = true;var dragonball = 'z'; 最后再声明未赋值的变量。当你需要引用前面的变量赋值时这将变的很有用。 123456789101112131415161718// badvar i, len, dragonball, items = getItems(), goSportsTeam = true;// badvar i;var items = getItems();var dragonball;var goSportsTeam = true;var len;// goodvar items = getItems();var goSportsTeam = true;var dragonball;var length;var i; 在作用域顶部声明变量。这将帮你避免变量声明提升相关的问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// badfunction () &#123; test(); console.log('doing stuff..'); //..other stuff.. var name = getName(); if (name === 'test') &#123; return false; &#125; return name;&#125;// goodfunction () &#123; var name = getName(); test(); console.log('doing stuff..'); //..other stuff.. if (name === 'test') &#123; return false; &#125; return name;&#125;// bad - 不必要的函数调用function () &#123; var name = getName(); if (!arguments.length) &#123; return false; &#125; this.setFirstName(name); return true;&#125;// goodfunction () &#123; var name; if (!arguments.length) &#123; return false; &#125; name = getName(); this.setFirstName(name); return true;&#125; ⬆ 回到顶部 提升 变量声明会提升至作用域顶部，但赋值不会。 123456789101112131415161718// 我们知道这样不能正常工作（假设这里没有名为 notDefined 的全局变量）function example() &#123; console.log(notDefined); // =&gt; throws a ReferenceError&#125;// 但由于变量声明提升的原因，在一个变量引用后再创建它的变量声明将可以正常工作。// 注：变量赋值为 `true` 不会提升。function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// 解释器会把变量声明提升到作用域顶部，意味着我们的例子将被重写成：function example() &#123; var declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125; 匿名函数表达式会提升它们的变量名，但不会提升函数的赋值。 123456789function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function () &#123; console.log('anonymous function expression'); &#125;;&#125; 命名函数表达式会提升变量名，但不会提升函数名或函数体。 12345678910111213141516171819202122function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() &#123; console.log('Flying'); &#125;;&#125;// 当函数名跟变量名一样时，表现也是如此。function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() &#123; console.log('named'); &#125;&#125; 函数声明提升它们的名字和函数体。 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125; 了解更多信息在 JavaScript Scoping &amp; Hoisting by Ben Cherry. ⬆ 回到顶部 比较运算符 &amp; 等号 优先使用 === 和 !== 而不是 == 和 !=. 条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则： 对象 被计算为 true Undefined 被计算为 false Null 被计算为 false 布尔值 被计算为 布尔的值 数字 如果是 +0、-0 或 NaN 被计算为 false，否则为 true 字符串 如果是空字符串 &#39;&#39; 被计算为 false，否则为 true 1234if ([0]) &#123; // true // 一个数组就是一个对象，对象被计算为 true&#125; 使用快捷方式。 12345678910111213141516171819// badif (name !== '') &#123; // ...stuff...&#125;// goodif (name) &#123; // ...stuff...&#125;// badif (collection.length &gt; 0) &#123; // ...stuff...&#125;// goodif (collection.length) &#123; // ...stuff...&#125; 了解更多信息在 Truth Equality and JavaScript by Angus Croll. ⬆ 回到顶部 块 使用大括号包裹所有的多行代码块。 12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction () &#123; return false; &#125;// goodfunction () &#123; return false;&#125; 如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。 12345678910111213141516// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125;// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125; ⬆ 回到顶部 注释 使用 /** ... */ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。 123456789101112131415161718192021222324252627// bad// make() returns a new element// based on the passed in tag name//// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// good/** * make() returns a new element * based on the passed in tag name * * @param &#123;String&#125; tag * @return &#123;Element&#125; element */function make(tag) &#123; // ...stuff... return element;&#125; 使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。 12345678910111213141516171819202122232425// badvar active = true; // is current tab// good// is current tabvar active = true;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this.type || 'no type'; return type;&#125;// goodfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this.type || 'no type'; return type;&#125; 给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME -- need to figure this out 或者 TODO -- need to implement。 使用 // FIXME: 标注问题。 1234567function Calculator() &#123; // FIXME: shouldn't use a global here total = 0; return this;&#125; 使用 // TODO: 标注问题的解决方式。 1234567function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; ⬆ 回到顶部 空白 使用 2 个空格作为缩进。 1234567891011121314// badfunction () &#123;∙∙∙∙var name;&#125;// badfunction () &#123;∙var name;&#125;// goodfunction () &#123;∙∙var name;&#125; 在大括号前放一个空格。 123456789101112131415161718192021// badfunction test()&#123; console.log('test');&#125;// goodfunction test() &#123; console.log('test');&#125;// baddog.set('attr',&#123; age: '1 year', breed: 'Bernese Mountain Dog'&#125;);// gooddog.set('attr', &#123; age: '1 year', breed: 'Bernese Mountain Dog'&#125;); 在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。 12345678910111213141516171819// badif(isJedi) &#123; fight ();&#125;// goodif (isJedi) &#123; fight();&#125;// badfunction fight () &#123; console.log ('Swooosh!');&#125;// goodfunction fight() &#123; console.log('Swooosh!');&#125; 使用空格把运算符隔开。 12345// badvar x=y+5;// goodvar x = y + 5; 在文件末尾插入一个空行。 1234// bad(function (global) &#123; // ...stuff...&#125;)(this); 12345// bad(function (global) &#123; // ...stuff...&#125;)(this);↵↵ 1234// good(function (global) &#123; // ...stuff...&#125;)(this);↵ 在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。 12345678910111213141516171819202122232425262728293031323334// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badvar leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);// goodvar leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); 在块末和新语句前插入空行。 1234567891011121314151617181920212223242526272829303132// badif (foo) &#123; return bar;&#125;return baz;// goodif (foo) &#123; return bar;&#125;return baz;// badvar obj = &#123; foo: function () &#123; &#125;, bar: function () &#123; &#125;&#125;;return obj;// goodvar obj = &#123; foo: function () &#123; &#125;, bar: function () &#123; &#125;&#125;;return obj; ⬆ 回到顶部 逗号 行首逗号: 不需要。 1234567891011121314151617181920212223242526272829// badvar story = [ once , upon , aTime];// goodvar story = [ once, upon, aTime];// badvar hero = &#123; firstName: 'Bob' , lastName: 'Parr' , heroName: 'Mr. Incredible' , superPower: 'strength'&#125;;// goodvar hero = &#123; firstName: 'Bob', lastName: 'Parr', heroName: 'Mr. Incredible', superPower: 'strength'&#125;; 额外的行末逗号：不需要。这样做会在 IE6/7 和 IE9 怪异模式下引起问题。同样，多余的逗号在某些 ES3 的实现里会增加数组的长度。在 ES5 中已经澄清了 (source)： Edition 5 clarifies the fact that a trailing comma at the end of an ArrayInitialiser does not add to the length of the array. This is not a semantic change from Edition 3 but some implementations may have previously misinterpreted this. 123456789101112131415161718192021// badvar hero = &#123; firstName: 'Kevin', lastName: 'Flynn',&#125;;var heroes = [ 'Batman', 'Superman',];// goodvar hero = &#123; firstName: 'Kevin', lastName: 'Flynn'&#125;;var heroes = [ 'Batman', 'Superman']; ⬆ 回到顶部 分号 使用分号。 1234567891011121314151617// bad(function () &#123; var name = 'Skywalker' return name&#125;)()// good(function () &#123; var name = 'Skywalker'; return name;&#125;)();// good (防止函数在两个 IIFE 合并时被当成一个参数;(function () &#123; var name = 'Skywalker'; return name;&#125;)(); 了解更多. ⬆ 回到顶部 类型转换 在语句开始时执行类型转换。 字符串： 12345678910111213// =&gt; this.reviewScore = 9;// badvar totalScore = this.reviewScore + '';// goodvar totalScore = '' + this.reviewScore;// badvar totalScore = '' + this.reviewScore + ' total score';// goodvar totalScore = this.reviewScore + ' total score'; 使用 parseInt 转换数字时总是带上类型转换的基数。 12345678910111213141516171819var inputValue = '4';// badvar val = new Number(inputValue);// badvar val = +inputValue;// badvar val = inputValue &gt;&gt; 0;// badvar val = parseInt(inputValue);// goodvar val = Number(inputValue);// goodvar val = parseInt(inputValue, 10); 如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。 1234567// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */var val = inputValue &gt;&gt; 0; 注： 小心使用位操作运算符。数字会被当成 64 位值，但是位操作运算符总是返回 32 位的整数（source）。位操作处理大于 32 位的整数值时还会导致意料之外的行为。讨论。最大的 32 位整数是 2,147,483,647： 1232147483647 &gt;&gt; 0 //=&gt; 21474836472147483648 &gt;&gt; 0 //=&gt; -21474836482147483649 &gt;&gt; 0 //=&gt; -2147483647 布尔: 12345678910var age = 0;// badvar hasAge = new Boolean(age);// goodvar hasAge = Boolean(age);// goodvar hasAge = !!age; ⬆ 回到顶部 命名规则 避免单字母命名。命名应具备描述性。 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 使用驼峰式命名对象、函数和实例。 123456789// badvar OBJEcttsssss = &#123;&#125;;var this_is_my_object = &#123;&#125;;var o = &#123;&#125;;function c() &#123;&#125;// goodvar thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125; 使用帕斯卡式命名构造函数或类。 1234567891011121314151617// badfunction user(options) &#123; this.name = options.name;&#125;var bad = new user(&#123; name: 'nope'&#125;);// goodfunction User(options) &#123; this.name = options.name;&#125;var good = new User(&#123; name: 'yup'&#125;); 不要使用下划线前/后缀。 为什么？JavaScript 并没有私有属性或私有方法的概念。虽然使用下划线是表示「私有」的一种共识，但实际上这些属性是完全公开的，它本身就是你公共接口的一部分。这种习惯或许会导致开发者错误的认为改动它不会造成破坏或者不需要去测试。长话短说：如果你想要某处为「私有」，它必须不能是显式提出的。 1234567// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda'; 不要保存 this 的引用。使用 Function#bind。 123456789101112131415161718192021222324252627282930// badfunction () &#123; var self = this; return function () &#123; console.log(self); &#125;;&#125;// badfunction () &#123; var that = this; return function () &#123; console.log(that); &#125;;&#125;// badfunction () &#123; var _this = this; return function () &#123; console.log(_this); &#125;;&#125;// goodfunction () &#123; return function () &#123; console.log(this); &#125;.bind(this);&#125; 给函数命名。这在做堆栈轨迹时很有帮助。 123456789// badvar log = function (msg) &#123; console.log(msg);&#125;;// goodvar log = function log(msg) &#123; console.log(msg);&#125;; 注： IE8 及以下版本对命名函数表达式的处理有些怪异。了解更多信息到 http://kangax.github.io/nfe/。 如果你的文件导出一个类，你的文件名应该与类名完全相同。 123456789101112131415// file contentsclass CheckBox &#123; // ...&#125;module.exports = CheckBox;// in some other file// badvar CheckBox = require('./checkBox');// badvar CheckBox = require('./check_box');// goodvar CheckBox = require('./CheckBox'); ⬆ 回到顶部 存取器 属性的存取函数不是必须的。 如果你需要存取函数时使用 getVal() 和 setVal(&#39;hello&#39;)。 1234567891011// baddragon.age();// gooddragon.getAge();// baddragon.age(25);// gooddragon.setAge(25); 如果属性是布尔值，使用 isVal() 或 hasVal()。 123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; 创建 get() 和 set() 函数是可以的，但要保持一致。 12345678910111213function Jedi(options) &#123; options || (options = &#123;&#125;); var lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber);&#125;Jedi.prototype.set = function set(key, val) &#123; this[key] = val;&#125;;Jedi.prototype.get = function get(key) &#123; return this[key];&#125;; ⬆ 回到顶部 构造函数 给对象原型分配方法，而不是使用一个新对象覆盖原型。覆盖原型将导致继承出现问题：重设原型将覆盖原有原型！ 1234567891011121314151617181920212223function Jedi() &#123; console.log('new jedi');&#125;// badJedi.prototype = &#123; fight: function fight() &#123; console.log('fighting'); &#125;, block: function block() &#123; console.log('blocking'); &#125;&#125;;// goodJedi.prototype.fight = function fight() &#123; console.log('fighting');&#125;;Jedi.prototype.block = function block() &#123; console.log('blocking');&#125;; 方法可以返回 this 来实现方法链式使用。 1234567891011121314151617181920212223242526272829// badJedi.prototype.jump = function jump() &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function setHeight(height) &#123; this.height = height;&#125;;var luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodJedi.prototype.jump = function jump() &#123; this.jumping = true; return this;&#125;;Jedi.prototype.setHeight = function setHeight(height) &#123; this.height = height; return this;&#125;;var luke = new Jedi();luke.jump() .setHeight(20); 写一个自定义的 toString() 方法是可以的，但是确保它可以正常工作且不会产生副作用。 123456789101112function Jedi(options) &#123; options || (options = &#123;&#125;); this.name = options.name || 'no name';&#125;Jedi.prototype.getName = function getName() &#123; return this.name;&#125;;Jedi.prototype.toString = function toString() &#123; return 'Jedi - ' + this.getName();&#125;; ⬆ 回到顶部 事件 当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法： 12345678// bad$(this).trigger('listingUpdated', listing.id);...$(this).on('listingUpdated', function (e, listingId) &#123; // do something with listingId&#125;); 更好的写法： 12345678// good$(this).trigger('listingUpdated', &#123; listingId : listing.id &#125;);...$(this).on('listingUpdated', function (e, data) &#123; // do something with data.listingId&#125;); ⬆ 回到顶部 模块 模块应该以 ! 开始。这样确保了当一个不好的模块忘记包含最后的分号时，在合并代码到生产环境后不会产生错误。详细说明 文件应该以驼峰式命名，并放在同名的文件夹里，且与导出的名字一致。 增加一个名为 noConflict() 的方法来设置导出的模块为前一个版本并返回它。 永远在模块顶部声明 &#39;use strict&#39;;。 123456789101112131415161718// fancyInput/fancyInput.js!function (global) &#123; 'use strict'; var previousFancyInput = global.FancyInput; function FancyInput(options) &#123; this.options = options || &#123;&#125;; &#125; FancyInput.noConflict = function noConflict() &#123; global.FancyInput = previousFancyInput; return FancyInput; &#125;; global.FancyInput = FancyInput;&#125;(this); ⬆ 回到顶部 jQuery 使用 $ 作为存储 jQuery 对象的变量名前缀。 12345// badvar sidebar = $('.sidebar');// goodvar $sidebar = $('.sidebar'); 缓存 jQuery 查询。 12345678910111213141516171819202122// badfunction setSidebar() &#123; $('.sidebar').hide(); // ...stuff... $('.sidebar').css(&#123; 'background-color': 'pink' &#125;);&#125;// goodfunction setSidebar() &#123; var $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; 'background-color': 'pink' &#125;);&#125; 对 DOM 查询使用层叠 $(&#39;.sidebar ul&#39;) 或 父元素 &gt; 子元素 $(&#39;.sidebar &gt; ul&#39;)。 jsPerf 对有作用域的 jQuery 对象查询使用 find。 1234567891011121314// bad$('ul', '.sidebar').hide();// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); ⬆ 回到顶部 ECMAScript 5 兼容性 参考 Kangax 的 ES5 兼容表. ⬆ 回到顶部","categories":[{"name":"前端规范","slug":"前端规范","permalink":"https://syhyz1990.github.io/categories/前端规范/"}],"tags":[{"name":"JS,ECMAScript5","slug":"JS-ECMAScript5","permalink":"https://syhyz1990.github.io/tags/JS-ECMAScript5/"}]},{"title":"移动端开发必读","slug":"mobile-development","date":"2018-02-06T11:09:11.000Z","updated":"2018-06-05T08:23:06.518Z","comments":true,"path":"wiki/mobile-development.html","link":"","permalink":"https://syhyz1990.github.io/wiki/mobile-development.html","excerpt":"","text":"移动端统计 (from BiosSun) 可基于下方所列出的统计数据来决定您要兼容的设备及浏览器。 百度移动统计 友盟指数 CNZZ 桌面及移动端浏览器统计 全球移动端浏览器统计 工具类网站 HTML5 与 CSS3 技术应用评估 各种奇妙的hack 几乎所有设备的屏幕尺寸与像素密度表 移动设备参数表 ios端移动设备参数速查 浏览器兼容表 移动设备查询器 移动设备适配库 移动设备适配库2 viewport与设备尺寸在线检测器 html5 移动端兼容性速查 在线转换字体 css3 选择器测试 测试浏览器对 ECMAScript6 的支持度 兼容性速查表 浏览器的一些独特参数 各种各样的媒体查询收集 css3 动画在线制作器 css3 渐变在线制作器 移动端手势表 webkit独有的样式分析 HTML5 Cross Browser Polyfills HTML5 POLYFILLS iphone6的那些事iPhone 6 屏幕揭秘 响应式测试工具Firefox 浏览器内置了 自定义设计视图 的功能，可以通过 Firefox-&gt;Web 开发者-&gt;自定义设计视图（或者摁下 Shift + Ctrl + m ）。相比网络工具，运行更加流畅，无需联网。 判断 iPad 和 iPhone 的版本和状态的 CSS 媒体查询代码 Viewport Resizer http://beta.screenqueri.es/ http://responsivepx.com http://www.responsinator.com/ http://resizemybrowser.com/ https://quirktools.com/screenfly/ 媒体查询常用样式表： &lt;link rel=&quot;stylesheet&quot; media=&quot;all and (orientation:portrait)&quot; href=&quot;portrait.css&quot;&gt; // 竖放加载 &lt;link rel=&quot;stylesheet&quot; media=&quot;all and (orientation:landscape)&quot;href=&quot;landscape.css&quot;&gt; // 横放加载 //竖屏时使用的样式 &lt;style media=&quot;all and (orientation:portrait)&quot; type=&quot;text/css&quot;&gt; #landscape { display: none; } &lt;/style&gt; //横屏时使用的样式 &lt;style media=&quot;all and (orientation:landscape)&quot; type=&quot;text/css&quot;&gt; #portrait { display: none; } &lt;/style&gt; Web app 开发的最佳实践与中文总结It’s not a web app. It’s an app you install from the web. 当前 WEB APP 开发的最佳实践 如何自适应网页屏幕以及配套的解决方案 手Q开发过程中经验沉淀webview性能优化 来自maxzhang的一些移动端经验总结干货移动Web单页应用开发实践——页面结构化 移动Web产品前端开发口诀——“快” 移动Web开发，4行代码检测浏览器是否支持position:fixed 使用border-image实现类似iOS7的1px底边 移动端web页面使用position:fixed问题总结 移动Web开发实践——解决position:fixed自适应BUG 移动手机浏览器m3u8格式视频流播放支持程度测试 本资料很多引用了指尖上的js系列 指尖下的js ——多触式web前端开发之一：对于Touch的处理 指尖下的js ——多触式web前端开发之二：处理简单手势 指尖下的js —— 多触式web前端开发之三：处理复杂手势 基础知识meta标签meta标签大全 http://segmentfault.com/blog/ciaocc/1190000002407912 meta标签，这些meta标签在开发webapp时起到非常重要的作用 &lt;meta content=&quot;width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0&quot; name=&quot;viewport&quot; /&gt; &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot; /&gt; &lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot; /&gt; &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt; 第一个meta标签表示：强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览；尤其要注意的是content里多个属性的设置一定要用分号+空格来隔开，如果不规范将不会起作用。 注意根据 public_00 提供的资料补充，content 使用分号作为分隔，在老的浏览器是支持的，但不是规范写法。 规范的写法应该是使用逗号分隔，参考 Safari HTML Reference - Supported Meta Tags 和 Android - Supporting Different Screens in Web Apps 其中： width - viewport的宽度 height - viewport的高度 initial-scale - 初始的缩放比例 minimum-scale - 允许用户缩放到的最小比例 maximum-scale - 允许用户缩放到的最大比例 user-scalable - 用户是否可以手动缩放 第二个meta标签是iphone设备中的safari私有meta标签，它表示：允许全屏模式浏览；第三个meta标签也是iphone的私有标签，它指定的iphone中safari顶端的状态条的样式；第四个meta标签表示：告诉设备忽略将页面中的数字识别为电话号码 在设置了initial-scale=1 之后，我们终于可以以1:1 的比例进行页面设计了。关于viewport，还有一个很重要的概念是：iphone 的safari 浏览器完全没有滚动条，而且不是简单的“隐藏滚动条”，是根本没有这个功能。iphone 的safari 浏览器实际上从一开始就完整显示了这个网页，然后用viewport 查看其中的一部分。当你用手指拖动时，其实拖的不是页面，而是viewport。浏览器行为的改变不止是滚动条，交互事件也跟普通桌面不一样。(请参考：指尖的下JS 系列文章) 更详细的 viewport 相关的知识也可以参考 此像素非彼像素 适配类文章移动端高清、多屏适配方案 手机淘宝的flexible设计与实现 移动开发事件手机浏览器常用手势动作监听封装 手势事件 touchstart //当手指接触屏幕时触发 touchmove //当已经接触屏幕的手指开始移动后触发 touchend //当手指离开屏幕时触发 touchcancel 触摸事件 gesturestart //当两个手指接触屏幕时触发 gesturechange //当两个手指接触屏幕后开始移动时触发 gestureend 屏幕旋转事件 onorientationchange 检测触摸屏幕的手指何时改变方向 orientationchange touch事件支持的相关属性 touches targetTouches changedTouches clientX // X coordinate of touch relative to the viewport (excludes scroll offset) clientY // Y coordinate of touch relative to the viewport (excludes scroll offset) screenX // Relative to the screen screenY // Relative to the screen pageX // Relative to the full page (includes scrolling) pageY // Relative to the full page (includes scrolling) target // Node the touch event originated from identifier // An identifying number, unique to each touch event 屏幕旋转事件：onorientationchange 判断屏幕是否旋转function orientationChange() { switch(window.orientation) { case 0: alert(&quot;肖像模式 0,screen-width: &quot; + screen.width + &quot;; screen-height:&quot; + screen.height); break; case -90: alert(&quot;左旋 -90,screen-width: &quot; + screen.width + &quot;; screen-height:&quot; + screen.height); break; case 90: alert(&quot;右旋 90,screen-width: &quot; + screen.width + &quot;; screen-height:&quot; + screen.height); break; case 180: alert(&quot;风景模式 180,screen-width: &quot; + screen.width + &quot;; screen-height:&quot; + screen.height); break; };}; 添加事件监听addEventListener(&apos;load&apos;, function(){ orientationChange(); window.onorientationchange = orientationChange; }); JS 单击延迟click 事件因为要等待单击确认，会有 300ms 的延迟，体验并不是很好。 开发者大多数会使用封装的 tap 事件来代替click 事件，所谓的 tap 事件由 touchstart 事件 + touchmove 判断 + touchend 事件封装组成。 Creating Fast Buttons for Mobile Web Applications Eliminate 300ms delay on click events in mobile Safari WebKit CSS:携程 UED 整理的 Webkit CSS 文档 ，全面、方便查询，下面为常用属性。 ①“盒模型”的具体描述性质的包围盒块内容，包括边界，填充等等。 -webkit-border-bottom-left-radius: radius; -webkit-border-top-left-radius: horizontal_radius vertical_radius; -webkit-border-radius: radius; //容器圆角 -webkit-box-sizing: sizing_model; 边框常量值：border-box/content-box -webkit-box-shadow: hoff voff blur color; //容器阴影（参数分别为：水平X 方向偏移量；垂直Y 方向偏移量；高斯模糊半径值；阴影颜色值） -webkit-margin-bottom-collapse: collapse_behavior; 常量值：collapse/discard/separate -webkit-margin-start: width; -webkit-padding-start: width; -webkit-border-image: url(borderimg.gif) 25 25 25 25 round/stretch round/stretch; -webkit-appearance: push-button; //内置的CSS 表现，暂时只支持push-button ②“视觉格式化模型”描述性质，确定了位置和大小的块元素。 direction: rtl unicode-bidi: bidi-override; 常量：bidi-override/embed/normal ③“视觉效果”描述属性，调整的视觉效果块内容，包括溢出行为，调整行为，能见度，动画，变换，和过渡。 clip: rect(10px, 5px, 10px, 5px) resize: auto; 常量：auto/both/horizontal/none/vertical visibility: visible; 常量: collapse/hidden/visible -webkit-transition: opacity 1s linear; 动画效果 ease/linear/ease-in/ease-out/ease-in-out -webkit-backface-visibility: visibler; 常量：visible(默认值)/hidden -webkit-box-reflect: right 1px; 镜向反转 -webkit-box-reflect: below 4px -webkit-gradient(linear, left top, left bottom, from(transparent), color-stop(0.5, transparent), to(white)); -webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)));; //CSS 遮罩/蒙板效果 -webkit-mask-attachment: fixed; 常量：fixed/scroll -webkit-perspective: value; 常量：none(默认) -webkit-perspective-origin: left top; -webkit-transform: rotate(5deg); -webkit-transform-style: preserve-3d; 常量：flat/preserve-3d; (2D 与3D) ④“生成的内容，自动编号，并列出”描述属性，允许您更改内容的一个组成部分，创建自动编号的章节和标题，和操纵的风格清单的内容。 content: “Item” counter(section) ” “; This resets the counter. First section &gt;two section three section counter-increment: section 1; counter-reset: section; ⑤“分页媒体”描述性能与外观的属性，控制印刷版本的网页，如分页符的行为。 page-break-after: auto; 常量：always/auto/avoid/left/right page-break-before: auto; 常量：always/auto/avoid/left/right page-break-inside: auto; 常量：auto/avoid ⑥“颜色和背景”描述属性控制背景下的块级元素和颜色的文本内容的组成部分。 -webkit-background-clip: content; 常量：border/content/padding/text -webkit-background-origin: padding; 常量：border/content/padding/text -webkit-background-size: 55px; 常量：length/length_x/length_y ⑦ “字型”的具体描述性质的文字字体的选择范围内的一个因素。报告还描述属性用于下载字体定义。 unicode-range: U+00-FF, U+980-9FF; ⑧“文本”描述属性的特定文字样式，间距和自动滚屏。 text-shadow: #00FFFC 10px 10px 5px; text-transform: capitalize; 常量：capitalize/lowercase/none/uppercase word-wrap: break-word; 常量：break-word/normal -webkit-marquee: right large infinite normal 10s; 常量：direction(方向) increment(迭代次数) repetition(重复) style(样式) speed(速度); -webkit-marquee-direction: ahead/auto/backwards/down/forwards/left/reverse/right/up -webkit-marquee-incrementt: 1-n/infinite(无穷次) -webkit-marquee-speed: fast/normal/slow -webkit-marquee-style: alternate/none/scroll/slide -webkit-text-fill-color: #ff6600; 常量：capitalize, lowercase, none, uppercase -webkit-text-security: circle; 常量：circle/disc/none/square -webkit-text-size-adjust: none; 常量:auto/none; -webkit-text-stroke: 15px #fff; -webkit-line-break: after-white-space; 常量：normal/after-white-space -webkit-appearance: caps-lock-indicator; -webkit-nbsp-mode: space; 常量： normal/space -webkit-rtl-ordering: logical; 常量：visual/logical -webkit-user-drag: element; 常量：element/auto/none -webkit-user-modify: read- only; 常量：read-write-plaintext-only/read-write/read-only -webkit-user-select: text; 常量：text/auto/none ⑨“表格”描述的布局和设计性能表的具体内容。 -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; -webkit-column-break-after: right; 常量：always/auto/avoid/left/right -webkit-column-break-before: right; 常量：always/auto/avoid/left/right –webkit-column-break-inside: logical; 常量：avoid/auto -webkit-column-count: 3; //分栏 -webkit-column-rule: 1px solid #fff; style:dashed,dotted,double,groove,hidden,inset,none,outset,ridge,solid ⑩“用户界面”描述属性，涉及到用户界面元素在浏览器中，如滚动文字区，滚动条，等等。报告还描述属性，范围以外的网页内容，如光标的标注样式和显示当您按住触摸触摸目标，如在iPhone上的链接。 -webkit-box-align: baseline,center,end,start,stretch 常量：baseline/center/end/start/stretch -webkit-box-direction: normal;常量：normal/reverse -webkit-box-flex: flex_valuet -webkit-box-flex-group: group_number -webkit-box-lines: multiple; 常量：multiple/single -webkit-box-ordinal-group: group_number -webkit-box-orient: block-axis; 常量：block-axis/horizontal/inline-axis/vertical/orientation –webkit-box-pack: alignment; 常量：center/end/justify/start 动画过渡这是 Webkit 中最具创新力的特性：使用过渡函数定义动画。 -webkit-animation: title infinite ease-in-out 3s; animation 有这几个属性： -webkit-animation-name： //属性名，就是我们定义的keyframes -webkit-animation-duration：3s //持续时间 -webkit-animation-timing-function： //过渡类型：ease/ linear(线性) /ease-in(慢到快)/ease-out(快到慢) /ease-in-out(慢到快再到慢) /cubic-bezier -webkit-animation-delay：10ms //动画延迟(默认0) -webkit-animation-iteration-count： //循环次数(默认1)，infinite 为无限 -webkit-animation-direction： //动画方式：normal(默认 正向播放)； alternate(交替方向，第偶数次正向播放，第奇数次反向播放) 这些同样是可以简写的。但真正让我觉的很爽的是keyframes，它能定义一个动画的转变过程供调用，过程为0%到100%或from(0%)到to(100%)。简单点说，只要你有想法，你想让元素在这个过程中以什么样的方式改变都是很简单的。 -webkit-transform: 类型（缩放scale/旋转rotate/倾斜skew/位移translate） scale(num,num) 放大倍率。scaleX 和 scaleY(3)，可以简写为：scale(* , *) rotate(*deg) 转动角度。rotateX 和 rotateY，可以简写为：rotate(* , *) Skew(*deg) 倾斜角度。skewX 和skewY，可简写为：skew(* , *) translate(*,*) 坐标移动。translateX 和translateY，可简写为：translate(* , *)。 自定义滚动条 from unknown 有没有觉得浏览器自带的原始滚动条很不美观，同时也有看到很多网站的自定义滚动条显得高端，就连chrome32.0开发板都抛弃了原始的滚动条，美观多了。那webkit浏览器是如何自定义滚动条的呢？ 参考： http://www.xuanfengge.com/css3-webkit-scrollbar.html http://www.zhaoan.org/849.html 后记：有时候，我们开发H5页面时为了美观，可能会隐藏滚动条，那么此时只要使用如下CSS代码即可实现 ::-webkit-scrollbar { width: 0; height: 0; } 页面描述&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;http://www.xxx.com/App_icon_114.png&quot; /&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;72x72&quot; href=&quot;http://www.xxx.com/App_icon_72.png&quot; /&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;http://www.xxx.com/App_icon_114.png&quot; /&gt; 这个属性是当用户把连接保存到手机桌面时使用的图标，如果不设置，则会用网页的截图。有了这，就可以让你的网页像APP一样存在手机里了 &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/img/startup.png&quot; /&gt; 这个是APP启动画面图片，用途和上面的类似，如果不设置，启动画面就是白屏，图片像素就是手机全屏的像素 &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt; 这个描述是表示打开的web app的最上面的时间、信号栏是黑色的，当然也可以设置其它参数，详细参数说明请参照：Safari HTML Reference - Supported Meta Tags &lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; 常见的 iPhone 和 Android 屏幕参数。 设备 分辨率 设备像素比率 Android LDPI 320×240 0.75 Iphone 3 &amp; Android MDPI 320×480 1 Android HDPI 480×800 1.5 Iphone 4 960×640 2.0 iPhone 4的一个 CSS 像素实际上表现为一块 2×2 的像素。所以图片像是被放大2倍一样，模糊不清晰。 解决办法： 1、页面引用 &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (-webkit-device-pixel-ratio: 0.75)&quot; href=&quot;ldpi.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (-webkit-device-pixel-ratio: 1.0)&quot; href=&quot;mdpi.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (-webkit-device-pixel-ratio: 1.5)&quot; href=&quot;hdpi.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (-webkit-device-pixel-ratio: 2.0)&quot; href=&quot;retina.css&quot; /&gt; 2、CSS文件里 #header { background:url(mdpi/bg.png); } @media screen and (-webkit-device-pixel-ratio: 1.5) { /*CSS for high-density screens*/ #header { background:url(hdpi/bg.png); } } 移动 Web 开发经验技巧性能优化技术相关 离线缓存 css优化【3d动画优化】 js优化 【js worker】 spdy,http2 service worker 入口dns预解析 域名收敛 cookie压缩 网速及网络情况侦测 webp 策略相关 前端资源压缩去重 首屏前置与资源lazyload 页面模板与数据分离 适当的base64,首屏css不建议使用 script 异步 后台智能加载下一页 图片渐进显示 参考资料7 天打造前端性能监控系统 16_ms_optimization—web_front-end_performance_optimization velocity 2011 移动互联网应用的性能优化 Medium图片加载模式 Web性能权威指南 Google 性能优化 http2资料汇总 离线缓存使用规范 12步创建高性能Web APP css加载方式 Google AMP (AMP is a way to build web pages for static content that render fast) 缓存最佳实践 以层为基础的渲染加速－chrome css3动画性能优化原理 点击与click事件对于a标记的点击导航，默认是在onclick事件中处理的。而移动客户端对onclick的响应相比PC浏览器有着明显的几百毫秒延迟。 在移动浏览器中对触摸事件的响应顺序应当是： ontouchstart -&gt; ontouchmove -&gt; ontouchend -&gt; onclick 因此，如果确实要加快对点击事件的响应，就应当绑定ontouchend事件。 使用click会出现绑定点击区域闪一下的情况，解决：给该元素一个样式如下 -webkit-tap-highlight-color: rgba(0,0,0,0); 如果不使用click，也不能简单的用touchstart或touchend替代，需要用touchstart的模拟一个click事件，并且不能发生touchmove事件，或者用zepto中的tap（轻击）事件。 body { -webkit-overflow-scrolling: touch; } 用iphone或ipad浏览很长的网页滚动时的滑动效果很不错吧？不过如果是一个div，然后设置 height:200px;overflow:auto;的话，可以滚动但是完全没有那滑动效果，很郁闷吧？ 我看到很多网站为了实现这一效果，用了第三方类库，最常用的是iscroll（包括新浪手机页，百度等）我一开始也使用，不过自从用了-webkit-overflow-scrolling: touch;样式后，就完全可以抛弃第三方类库了，把它加在body{}区域，所有的overflow需要滚动的都可以生效了。 另外有一篇比较全的移动端点击解决方案 http://www.zhihu.com/question/28979857 锁定 viewportontouchmove=&quot;event.preventDefault()&quot; //锁定viewport，任何屏幕操作不移动用户界面（弹出键盘除外）。 利用 Media Query监听Media Query 相信大部分人已经使用过了。其实 JavaScript可以配合 Media Query这么用： var mql = window.matchMedia(&quot;(orientation: portrait)&quot;); mql.addListener(handleOrientationChange); handleOrientationChange(mql); function handleOrientationChange(mql) { if (mql.matches) { alert(&apos;The device is currently in portrait orientation &apos;) } else { alert(&apos;The device is currently in landscape orientation&apos;) }} 借助了 Media Query 接口做的事件监听，所以很强大！ 也可以通过获取 CSS 值来使用 Media Query 判断设备情况，详情请看：JavaScript 依据 CSS Media Queries 判断设备的方法。 使用gpu判断iphone型号参考 http://www.sohu.com/a/157376672_505818 https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/HardwareGPUInformation/HardwareGPUInformation.html 每一代 iOS 设备的 GPU 型号都是不同的，比如 iPhone 6 是 A8，而 iPhone 6s 就是 A9。可以通过识别 GPU 的型号来辨别设备的型号。有些设备 GPU 型号完全相同，比如 iPhone 6s ，iPhone 6s Plus ， iPhone SE 。它们用的都是 Apple A9 GPU ，这个时候可以利用它们的分辨率不同来进行区分。 实例代码 https://github.com/joyqi/mobile-device-js rem最佳实践rem是非常好用的一个属性，可以根据html来设定基准值，而且兼容性也很不错。不过有的时候还是需要对一些莫名其妙的浏览器优雅降级。以下是两个实践 http://jsbin.com/vaqexuge/4/edit 这有个demo，发现chrome当font-size小于12时，rem会按照12来计算。因此设置基准值要考虑这一点 可以用以下的代码片段保证在低端浏览器下也不会出问题 html { font-size: 62.5%; } body { font-size: 14px; font-size: 1.4rem; } /* =14px */ h1 { font-size: 24px; font-size: 2.4rem; } /* =24px */ 被点击元素的外观变化，可以使用样式来设定：-webkit-tap-highlight-color: 颜色 iphoneX 适配http://www.w3cplus.com/mobile/designing-websites-for-iphone-x.html 检测判断 iPhone/iPod开发特定设备的移动网站，首先要做的就是设备侦测了。下面是使用Javascript侦测iPhone/iPod的UA，然后转向到专属的URL。 if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPod/i))) { if (document.cookie.indexOf(&quot;iphone_redirect=false&quot;) == -1) { window.location = &quot;http://m.example.com&quot;; } } 判断软键盘弹出 android上，当软键盘状态改变的时候，会触发window的resize事件，所以我们可以进入页面的时候保存一次window.innerHeight的值，当window的resize事件触发的时候，比较window.innerHeight的值与前一次保存的window.innerHeight的值大小来判断软键盘的收拢和弹出状态。 var winHeight = window.innerHeight; if (isAndroid) { window.addEventListener(&apos;resize&apos;, function(e) { var tempHeight = window.innerHeight if (tempHeight &lt; winHeight) { bShowRec = false; } else { bShowRec = true; } }); } ios上，软键盘状态改变的时候，不会触发window的resize事件，但是当软键盘的“完成”按钮被点击的时候，会触发onblur事件。所以正常通过onfocus和onblur事件来判断就行。 虽然Javascript是可以在水果设备上运行的，但是用户还是可以禁用。它也会造成客户端刷新和额外的数据传输，所以下面是服务器端侦测和转向： if(strstr($_SERVER[&apos;HTTP_USER_AGENT&apos;],&apos;iPhone&apos;) || strstr($_SERVER[&apos;HTTP_USER_AGENT&apos;],&apos;iPod&apos;)) { header(&apos;Location: http://yoursite.com/iphone&apos;); exit(); } 阻止旋转屏幕时自动调整字体大小html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 {-webkit-text-size-adjust:none;} 禁止body滚动document.body.ontouchmove=function(e){ e.preventDefault(); } 页面长按，高亮全选文本&lt;http://blog.csdn.net/freshlover/article/details/40432247&gt; 模拟:hover伪类因为iPhone并没有鼠标指针，所以没有hover事件。那么CSS :hover伪类就没用了。但是iPhone有Touch事件，onTouchStart 类似 onMouseOver，onTouchEnd 类似 onMouseOut。所以我们可以用它来模拟hover。使用Javascript： var myLinks = document.getElementsByTagName(&apos;a&apos;); for(var i = 0; i &lt; myLinks.length; i++){ myLinks[i].addEventListener(’touchstart’, function(){this.className = “hover”;}, false); myLinks[i].addEventListener(’touchend’, function(){this.className = “”;}, false); } 然后用CSS增加hover效果： a:hover, a.hover { /* 你的hover效果 */ } 这样设计一个链接，感觉可以更像按钮。并且，这个模拟可以用在任何元素上。 Flexbox 布局 Flex 模板和实例 深入了解 Flexbox 伸缩盒模型 CSS Flexbox Intro http://www.w3.org/TR/css3-flexbox/ 3dTouch相关https://developer.mozilla.org/en-US/docs/Web/API/Force_Touch_events https://aotu.io/notes/2016/09/28/3d-touch/ pwa与service workerhttps://segmentfault.com/a/1190000005641692 pwa介绍 https://zhuanlan.zhihu.com/p/20040372 service woker介绍 http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207243549&amp;idx=1&amp;sn=4ebe4beb8123f1b5ab58810ac8bc5994&amp;scene=0#rd 微信与其它app的推送技术介绍 https://segmentfault.com/a/1190000005346689 pwa资料整理 https://segmentfault.com/a/1190000010911535 pwa 最新资讯 居中问题居中是移动端跟pc端共同的噩梦。这里有两种兼容性比较好的新方案。 table布局法 .box{ text-align:center; display:table-cell; vertical-align:middle; } 老版本flex布局法 .box{ display:-webkit-box; -webkit-box-pack: center; -webkit-box-align: center; text-align:center; } 以上两种其实分别是retchat跟ionic的布局基石。 这里有更详细的更多的选择http://www.zhouwenbin.com/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/ 来自周文彬的博客 h5底部输入框被键盘遮挡问题h5页面有个很蛋疼的问题就是，当输入框在最底部，点击软键盘后输入框会被遮挡。 可以使用这个api，在点击input的时候调用即可 https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView 如果切换输入法，由于不同输入法高度不同，又会出现被遮挡问题。由于无法捕获切换输入法的事件，因此可以开一个计时器，不断执行sscrollintoview即可。 移动端实现标题文字截断http://www.75team.com/archives/611 ios实现复制到剪贴板var $input = $(&apos; some input/textarea &apos;); $input.val(result); if (navigator.userAgent.match(/ipad|ipod|iphone/i)) { var el = $input.get(0); var editable = el.contentEditable; var readOnly = el.readOnly; el.contentEditable = true; el.readOnly = false; var range = document.createRange(); range.selectNodeContents(el); var sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range); el.setSelectionRange(0, 999999); el.contentEditable = editable; el.readOnly = readOnly; } else { $input.select(); } document.execCommand(&apos;copy&apos;); $input.blur(); placeholder–line-height input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal，（stackoverflow也可查到这种解决办法）。 处理 Retina 双倍屏幕 （经典）Using CSS Sprites to optimize your website for Retina Displays 使用CSS3的background-size优化苹果的Retina屏幕的图像显示 使用 CSS sprites 来优化你的网站在 Retina 屏幕下显示 （案例）CSS IMAGE SPRITES FOR RETINA (HIRES) DEVICES input类型为date情况下不支持placeholder（来自于江水）这其实是浏览器自己的处理。因为浏览器会针对此类型 input 增加 datepicker 模块。 对 input type date 使用 placeholder 的目的是为了让用户更准确的输入日期格式，iOS 上会有 datepicker 不会显示 placeholder 文字，但是为了统一表单外观，往往需要显示。Android 部分机型没有 datepicker 也不会显示 placeholder 文字。 桌面端（Mac） Safari 不支持 datepicker，placeholder 正常显示。 Firefox 不支持 datepicker，placeholder 正常显示。 Chrome 支持 datepicker，显示 年、月、日 格式，忽略 placeholder。 移动端 iPhone5 iOS7 有 datepicker 功能，但是不显示 placeholder。 Andorid 4.0.4 无 datepicker 功能，不显示 placeholder 解决方法： &lt;input placeholder=&quot;Date&quot; class=&quot;textbox-n&quot; type=&quot;text&quot; onfocus=&quot;(this.type=&apos;date&apos;)&quot; id=&quot;date&quot;&gt; 因为text是支持placeholder的。因此当用户focus的时候自动把type类型改变为date，这样既有placeholder也有datepicker了 ###iphone系列媒体查询 @media only screen and (min-device-width: 320px){ //针对iPhone 3} @media only screen and (min-device-width: 320px)and (-webkit-min-device-pixel-ratio: 2) { //针对iPhone 4, 5c,5s, 所有iPhone6的放大模式，个别iPhone6的标准模式}@media only screen and (min-device-width: 375px)and (-webkit-min-device-pixel-ratio: 2) {//针对大多数iPhone6的标准模式} @media only screen and (min-device-width: 375px)and (-webkit-min-device-pixel-ratio: 3) {//针对所有iPhone6+的放大模式 }@media only screen and (min-device-width:412px) and (-webkit-min-device-pixel-ratio: 3) {//针对所有iPhone6+的标准模式,414px写为412px是由于三星Nexus 6为412px，可一并处理 } 判断照片的横竖排列有这样一种需求，需要判断用户照片是横着拍出来的还是竖着拍出来的，这里需要使用照片得exif信息： $(&quot;input&quot;).change(function() { var file = this.files[0]; fr = new FileReader; fr.onloadend = function() { var exif = EXIF.readFromBinaryFile(new BinaryFile(this.result)); alert(exif.Orientation); }; fr.readAsBinaryString(file); }); 可以使用这两个库 来取exif信息http://www.nihilogic.dk/labs/binaryajax/binaryajax.js http://www.nihilogic.dk/labs/exif/exif.js Android上当viewport的width大于device-width时出现文字无故折行的解决办法http://www.iunbug.com/archives/2013/04/23/798.html 白屏解决与优化方案当前很多无线页面都使用前端模板进行数据渲染，那么在糟糕的网速情况下，一进去页面，看到的不是白屏就是 loading，这成为白屏问题。 此问题发生的原因基本可以归结为网速跟静态资源 1、css文件加载需要一些时间，在加载的过程中页面是空白的。 解决：可以考虑将css代码前置和内联。2、首屏无实际的数据内容，等待异步加载数据再渲染页面导致白屏。 解决：在首屏直接同步渲染html，后续的滚屏等再采用异步请求数据和渲染html。3、首屏内联js的执行会阻塞页面的渲染。 解决：尽量不在首屏html代码中放置内联脚本。（来自翔歌） 解决方案 根本原因是客户端渲染的无力，因此最简单的方法是在服务器端，使用模板引擎渲染所有页面。同时 1减少文件加载体积，如html压缩，js压缩 2加快js执行速度 比如常见的无限滚动的页面，可以使用js先渲染一个屏幕范围内的东西 3提供一些友好的交互，比如提供一些假的滚动条 4使用本地存储处理静态文件。 h5 小特效实践加速度感应（摇一摇） if (window.DeviceMotionEvent) { window.addEventListener(‘devicemotion’,deviceMotionHandler, false); } var speed = 30;//speed var x = y = z = lastX = lastY = lastZ = 0; function deviceMotionHandler(eventData) { var acceleration =event.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; if(Math.abs(x-lastX) &gt; speed || Math.abs(y-lastY) &gt; speed || Math.abs(z-lastZ) &gt; speed) { alert(‘别摇那么大力嘛…’); // your code here } lastX = x; lastY = y; lastZ = z; } 抽奖转盘刮彩票全景效果描边动画翻书如何实现打开已安装的app，若未安装则引导用户安装?来自 http://gallery.kissyui.com/redirectToNative/1.2/guide/index.html kissy mobile通过iframe src发送请求打开app自定义url scheme，如taobao://home（淘宝首页） 、etao://scan（一淘扫描）);如果安装了客户端则会直接唤起，直接唤起后，之前浏览器窗口（或者扫码工具的webview）推入后台；如果在指定的时间内客户端没有被唤起，则js重定向到app下载地址。大概实现代码如下 goToNative:function(){ if(!body) { setTimeout(function(){ doc.body.appendChild(iframe); }, 0); } else { body.appendChild(iframe); } setTimeout(function() { doc.body.removeChild(iframe); gotoDownload(startTime);//去下载，下载链接一般是itunes app store或者apk文件链接 /** * 测试时间设置小于800ms时，在android下的UC浏览器会打开native app时并下载apk， * 测试android+UC下打开native的时间最好大于800ms; */ }, 800); } 需要注意的是 如果是android chrome 25版本以后，在iframe src不会发送请求，原因如下https://developers.google.com/chrome/mobile/docs/intents ，通过location href使用intent机制拉起客户端可行并且当前页面不跳转。 window.location = &apos;intent://&apos; + schemeUrl + &apos;#Intent;scheme=&apos; + scheme + &apos;;package=&apos; + self.package + &apos;;end&apos;; 补充一个来自三水清的详细讲解 http://js8.in/2013/12/16/ios%E4%BD%BF%E7%94%A8schema%E5%8D%8F%E8%AE%AE%E8%B0%83%E8%B5%B7app/ 在微信、微博、QQ、Safari唤起App的解决方案汇总 ： https://mp.weixin.qq.com/s/YAnlEBMZP_e91MXjPbAp-w active的兼容(来自薛端阳)今天发现，要让a链接的CSS active伪类生效，只需要给这个a链接的touch系列的任意事件touchstart/touchend绑定一个空的匿名方法即可hack成功 &lt;style&gt; a { color: #000; } a:active { color: #fff; } &lt;/style&gt; &lt;a herf=”asdasd”&gt;asdasd&lt;/a&gt; &lt;script&gt; var a=document.getElementsByTagName(‘a’); for(var i=0;i&lt;a.length;i++){ a[i].addEventListener(‘touchstart’,function(){},false); } &lt;/script&gt; 视频播放的各种技术http://taobaofed.org/blog/2016/05/23/video-player/ 消除transition闪屏两个方法：使用css3动画的时尽量利用3D加速，从而使得动画变得流畅。动画过程中的动画闪白可以通过 backface-visibility 隐藏。 -webkit-transform-style: preserve-3d; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-backface-visibility: hidden; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ 测试是否支持svg图片document.implementation.hasFeature(&quot;http:// www.w3.org/TR/SVG11/feature#Image&quot;, &quot;1.1&quot;) 考虑兼容“隐私模式”(from http://blog.youyo.name/archives/smarty-phones-webapp-deverlop-advance.html)ios的safari提供一种“隐私模式”，如果你的webapp考虑兼容这个模式，那么在使用html5的本地存储的一种————localStorage时，可能因为“隐私模式”下没有权限读写localstorge而使代码抛出错误，导致后续的js代码都无法运行了。 既然在safari的“隐私模式”下，没有调用localStorage的权限，首先想到的是先判断是否支持localStorage，代码如下： if(&apos;localStorage&apos; in window){ //需要使用localStorage的代码写在这 }else{ //不支持的提示和向下兼容代码 } 测试发现，即使在safari的“隐私模式”下，’localStorage’ in window的返回值依然为true，也就是说，if代码块内部的代码依然会运行，问题没有得到解决。接下来只能相当使用try catch了，虽然这是一个不太推荐被使用的方法，使用try catch捕获错误，使后续的js代码可以继续运行，代码如下： try{ if(&apos;localStorage&apos; in window){ //需要使用localStorage的代码写在这 }else{ //不支持的提示和向下兼容代码 } }catch(e){ // 隐私模式相关提示代码和不支持的提示和向下兼容代码 } 所以，提醒大家注意，在需要兼容ios的safari的“隐私模式”的情况下，本地存储相关的代码需要使用try catch包裹并降级兼容。 安卓手机点击锁定页面效果问题有些安卓手机，页面点击时会停止页面的javascript，css3动画等的执行，这个比较蛋疼。不过可以用阻止默认事件解决。详细见http://stackoverflow.com/questions/10246305/android-browser-touch-events-stop-display-being-updated-inc-canvas-elements-h function touchHandlerDummy(e) { e.preventDefault(); return false; } document.addEventListener(&quot;touchstart&quot;, touchHandlerDummy, false); document.addEventListener(&quot;touchmove&quot;, touchHandlerDummy, false); document.addEventListener(&quot;touchend&quot;, touchHandlerDummy, false); 消除ie10里面的那个叉号IE Pseudo-elements input:-ms-clear{display:none;} 关于ios与os端字体的优化(横竖屏会出现字体加粗不一致等)mac下网页中文字体优化 UIWebView font is thinner in portrait than landscape 判断用户是否是“将网页添加到主屏后，再从主屏幕打开这个网页”的navigator.standalone 隐藏地址栏 &amp; 处理事件的时候，防止滚动条出现：// 隐藏地址栏 &amp; 处理事件的时候 ，防止滚动条出现 addEventListener(&apos;load&apos;, function(){ setTimeout(function(){ window.scrollTo(0, 1); }, 100); }); ios7 可以通过meta标签的minimal来隐藏地址栏了http://darkblue.sdf.org/weblog/ios-7-dot-1-mobile-safari-minimal-ui.html 判断是否为iPhone：// 判断是否为 iPhone ： function isAppleMobile() { return (navigator.platform.indexOf(&apos;iPhone&apos;) != -1); }; localStorage:var v = localStorage.getItem(&apos;n&apos;) ? localStorage.getItem(&apos;n&apos;) : &quot;&quot;; // 如果名称是 n 的数据存在 ，则将其读出 ，赋予变量 v 。 localStorage.setItem(&apos;n&apos;, v); // 写入名称为 n、值为 v 的数据 localStorage.removeItem(&apos;n&apos;); // 删除名称为 n 的数据 使用特殊链接：如果你关闭自动识别后 ，又希望某些电话号码能够链接到 iPhone 的拨号功能 ，那么可以通过这样来声明电话链接 , &lt;a href=&quot;tel:12345654321&quot;&gt;打电话给我&lt;/a&gt; &lt;a href=&quot;sms:12345654321&quot;&gt;发短信&lt;/a&gt; 或用于单元格： &lt;td onclick=&quot;location.href=&apos;tel:122&apos;&quot;&gt; 自动大写与自动修正要关闭这两项功能，可以通过autocapitalize 与autocorrect 这两个选项： &lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt; 不让 Android 识别邮箱&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt; 禁止 iOS 弹出各种操作窗口-webkit-touch-callout:none 禁止用户选中文字-webkit-user-select:none 动画效果中，使用 translate 比使用定位性能高Why Moving Elements With Translate() Is Better Than Pos:abs Top/left webgl导致app闪退iOS 客户端切到后台后如果 webgl 在canvas上渲染会导致客户端crash。原因是 iOS 下使用 webgl 渲染时，WebCore 会调用到 OpenGL ES 进行渲染，而苹果发现有在后台调用 OpenGL ES，就会直接结束 App。相关文档 https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/ImplementingaMultitasking-awareOpenGLESApplication/ImplementingaMultitasking-awareOpenGLESApplication.html。 解决方案：一般的客户端容器技术（phonegap weex等）都提供了监测app切换的事件，在事件中主动暂停/恢复 webgl 的渲染即可 拿到滚动条window.scrollY window.scrollX 比如要绑定一个touchmove的事件，正常的情况下类似这样(来自呼吸二氧化碳) $(&apos;div&apos;).on(&apos;touchmove&apos;, function(){ //.….code {}); 而如果中间的code需要处理的东西多的话，fps就会下降影响程序顺滑度，而如果改成这样 $(&apos;div&apos;).on(&apos;touchmove&apos;, function(){ setTimeout(function(){ //.….code },0); {}); 把代码放在setTimeout中，会发现程序变快. 关于 iOS 系统中，Web APP 启动图片在不同设备上的适应性设置http://stackoverflow.com/questions/4687698/mulitple-apple-touch-startup-image-resolutions-for-ios-web-app-esp-for-ipad/10011893#10011893 position:sticky与position:fixed布局http://www.zhouwenbin.com/positionsticky-%E7%B2%98%E6%80%A7%E5%B8%83%E5%B1%80/http://www.zhouwenbin.com/sticky%E6%A8%A1%E6%8B%9F%E9%97%AE%E9%A2%98/ 关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格可以通过正则去掉 this.value = this.value.replace(/\\u2006/g, &apos;&apos;); 关于android webview中，input元素输入时出现的怪异情况见下图 Android Web 视图,至少在 HTC EVO 和三星的 Galaxy Nexus 中，文本输入框在输入时表现的就像占位符。情况为一个类似水印的东西在用户输入区域，一旦用户开始输入便会消失(见图片)。 在 Android 的默认样式下当输入框获得焦点后，若存在一个绝对定位或者 fixed 的元素，布局会被破坏，其他元素与系统输入字段会发生重叠(如搜索图标将消失为搜索字段)，可以观察到布局与原始输入字段有偏差(见截图)。 这是一个相当复杂的问题，以下简单布局可以重现这个问题: &lt;label for=&quot;phone&quot;&gt;Phone: *&lt;/label&gt; &lt;input type=&quot;tel&quot; name=&quot;phone&quot; id=&quot;phone&quot; minlength=&quot;10&quot; maxlength=&quot;10&quot; inputmode=&quot;latin digits&quot; required=&quot;required&quot; /&gt; 解决方法 -webkit-user-modify: read-write-plaintext-only 详细参考http://www.bielousov.com/2012/android-label-text-appears-in-input-field-as-a-placeholder/注意，该属性会导致中文不能输入词组，只能单个字。感谢鬼哥与飞（游勇飞）贡献此问题与解决方案 另外，在position:fixed后的元素里，尽量不要使用输入框。更多的bug可参考http://www.cosdiv.com/page/M0/S882/882353.html 依旧无法解决（摩托罗拉ME863手机），则使用input:text类型而非password类型，并设置其设置 -webkit-text-security: disc; 隐藏输入密码从而解决。 JS动态生成的select下拉菜单在Android2.x版本的默认浏览器里不起作用解决方法删除了overflow-x:hidden; 然后在JS生成下来菜单之后focus聚焦，这两步操作之后解决了问题。(来自岛都-小Qi) 参考http://stackoverflow.com/questions/4697908/html-select-control-disabled-in-android-webview-in-emulator Andriod 上去掉语音输入按钮input::-webkit-input-speech-button {display: none} IE10 的特殊鼠标事件IE10 事件监听 iOS 输入框最佳实践Mobile-friendly input of a digits + spaces string (a credit card number) HTML5 input type number vs tel iPhone: numeric keyboard for text input Text Programming Guide for iOS - Managing the Keyboard HTML5 inputs and attribute support 往返缓存问题点击浏览器的回退，有时候不会自动执行js，特别是在mobilesafari中。这与往返缓存(bfcache)有关系。有很多hack的处理方法，可以参考 http://stackoverflow.com/questions/24046/the-safari-back-button-problem http://stackoverflow.com/questions/11979156/mobile-safari-back-button 不暂停的计时器（safari的进程冻结）https://www.imququ.com/post/ios-none-freeze-timer.html或者可以用postmessage方式:主页面: // 解决ios safari tab在后台会遭遇进程冻结问题 // http://www.apple.com/safari/#gallery-icloud-tabs // Safari takes advantage of power-saving technologies such as App Nap, which puts background Safari tabs into a low-power state until you start using them again. In addition, Safari Power Saver conserves battery life by intelligently pausing web videos and other plug‑in content when they’re not front and center on the web pages you visit. All told, Safari on OS X Mavericks lets you browse up to an hour longer than with Chrome or Firefox.1 var work; function startWorker() { if (typeof(Worker) !== &quot;undefined&quot;) { if (typeof(work) == &quot;undefined&quot;) { work = new Worker(&quot;/workers.js&quot;); } work.onmessage = function(event) { // document.getElementById(&quot;result-count&quot;).innerHTML = event.data.count; // document.getElementById(&quot;result-url&quot;).innerHTML = event.data.targetURL; if (target &amp;&amp; event.data.targetURL != &quot;&quot;) target.location.href = event.data.targetURL; }; } else { console.log(&apos;does not support Web Workers...&apos;); } } function stopWorker() { work.terminate(); } startWorker(); worker: // 解决ios safari tab在后台会遭遇进程冻结问题 // http://www.apple.com/safari/#gallery-icloud-tabs // Safari takes advantage of power-saving technologies such as App Nap, which puts background Safari tabs into a low-power state until you start using them again. In addition, Safari Power Saver conserves battery life by intelligently pausing web videos and other plug‑in content when they’re not front and center on the web pages you visit. All told, Safari on OS X Mavericks lets you browse up to an hour longer than with Chrome or Firefox.1 importScripts(&apos;/socket.io/socket.io.js&apos;); var count = 0, targetURL = &apos;&apos; ; var socket = io.connect(&apos;/&apos;); socket.on(&apos;navigate&apos;, function (data) { count = count++; postMessage({targetURL:data.url,count:count}); }); Web移动端Fixed布局的解决方案http://efe.baidu.com/blog/mobile-fixed-layout/ ios上background-attachment:fixed不能正常工作参考 http://stackoverflow.com/questions/20443574/fixed-background-image-with-ios7 在高清屏幕上实现 1px 的几种方案 http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html http://www.cnblogs.com/lunarorbitx/p/5287309.html 如何让音频跟视频在ios跟android上自动播放&lt;audio autoplay &gt;&lt;source src=&quot;audio/alarm1.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/audio&gt; 系统默认情况下 audio的autoplay属性是无法生效的，这也是手机为节省用户流量做的考虑。如果必须要自动播放，有两种方式可以解决。 1.捕捉一次用户输入后，让音频加载，下次即可播放。 //play and pause it once document.addEventListener(&apos;touchstart&apos;, function () { document.getElementsByTagName(&apos;audio&apos;)[0].play(); document.getElementsByTagName(&apos;audio&apos;)[0].pause(); }); 这种方法需要捕获一次用户的点击事件来促使音频跟视频加载。当加载后，你就可以用javascript控制音频的播放了，如调用audio.play() 2.利用iframe加载资源 var ifr=document.createElement(&quot;iframe&quot;); ifr.setAttribute(&apos;src&apos;, &quot;http://mysite.com/myvideo.mp4&quot;); ifr.setAttribute(&apos;width&apos;, &apos;1px&apos;); ifr.setAttribute(&apos;height&apos;, &apos;1px&apos;); ifr.setAttribute(&apos;scrolling&apos;, &apos;no&apos;); ifr.style.border=&quot;0px&quot;; document.body.appendChild(ifr); 这种方式其实跟第一种原理是一样的。当资源加载了你就可以控制播放了，但是这里使用iframe来加载，相当于直接触发资源加载。注意，使用创建audio标签并让其加载的方式是不可行的。慎用这种方法，会对用户造成很糟糕的影响。。 iOS 6 跟 iPhone 5 的那些事IP5 的媒体查询@media (device-height: 568px) and (-webkit-min-device-pixel-ratio: 2) { /* iPhone 5 or iPod Touch 5th generation */ } 使用媒体查询，提供不同的启动图片：&lt;link href=&quot;startup-568h.png&quot; rel=&quot;apple-touch-startup-image&quot; media=&quot;(device-height: 568px)&quot;&gt; &lt;link href=&quot;startup.png&quot; rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x920&quot; media=&quot;(device-height: 480px)&quot;&gt; 拍照上传&lt;input type=file accept=&quot;video/*&quot;&gt; &lt;input type=file accept=&quot;image/*&quot;&gt; 不支持其他类型的文件 ，如音频，Pages文档或PDF文件。 也没有getUserMedia摄像头的实时流媒体支持。 可以使用的 HTML5 高级 api multipart POST 表单提交上传 XMLHttpRequest 2 AJAX 上传（甚至进度支持） 文件 API ，在 iOS 6 允许 JavaScript 直接读取的字节数和客户端操作文件。 智能应用程序横幅有了智能应用程序横幅，当网站上有一个相关联的本机应用程序时，Safari浏览器可以显示一个横幅。 如果用户没有安装这个应用程序将显示“安装”按钮，或已经安装的显示“查看”按钮可打开它。 在 iTunes Link Maker 搜索我们的应用程序和应用程序ID。 &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=9999999&quot;&gt; 可以使用 app-argument 提供字符串值，如果参加iTunes联盟计划，可以添加元标记数据 &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=9999999, app-argument=xxxxxx&quot;&gt; &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=9999999, app-argument=xxxxxx, affiliate-data=partnerId=99&amp;siteID=XXXX&quot;&gt; 横幅需要156像素（设备是312 hi-dpi）在顶部，直到用户在下方点击内容或关闭按钮，你的网站才会展现全部的高度。 它就像HTML的DOM对象，但它不是一个真正的DOM。 CSS3 滤镜 -webkit-filter: blur(5px) grayscale (.5) opacity(0.66) hue-rotate(100deg); 交叉淡变 background-image: -webkit-cross-fade(url(&quot;logo1.png&quot;), url(&quot;logo2.png&quot;), 50%); Safari中的全屏幕 除了chrome-less 主屏幕meta标签，现在的iPhone和iPod Touch（而不是在iPad）支持全屏幕模式的窗口。 没有办法强制全屏模式，它需要由用户启动（工具栏上的最后一个图标）。需要引导用户按下屏幕上的全屏图标来激活全屏效果。 可以使用onresize事件检测是否用户切换到全屏幕。 支持requestAnimationFrameAPI 支持image-set,retina屏幕的利器 -webkit-image-set(url(low.png) 1x, url(hi.jpg) 2x) 应用程序缓存限制增加至25MB。 Web View（pseudobrowsers，PhoneGap/Cordova应用程序，嵌入式浏览器） 上Javascript运行比Safari慢3.3倍（或者说，Nitro引擎在Safari浏览器是Web应用程序是3.3倍速度）。 autocomplete属性的输入遵循DOM规范 来自DOM4的Mutation Observers已经实现。 您可以使用WebKitMutationObserver构造器捕获DOM的变化 Safari不再总是对用 -webkit-transform:preserve-3d 的元素创建硬件加速 支持window.selection 的Selection API Canvas更新 ：createImageData有一个参数，现在有两个新的功能做好准备，用webkitGetImageDataHD和webkitPutImageDataHD提供高分辨率图像 。 更新SVG处理器和事件构造函数 IOS7的大更新iOS 7 的 Safari 和 HTML5：问题，变化和新 API(张金龙翻译) iOS 7 的一些坑(英文) ios7的一些坑2(英文) IOS10的一些更新 禁止缩放，meta不再支持1&lt;meta name=\"viewport\" content=\"initial-scale=1.0, user-scalable=no\" /&gt; 需要监听touchmove来实现禁止缩放123456document.addEventListener('touchmove', function(event) &#123; event = event.originalEvent || event; if(event.scale &gt; 1) &#123; event.preventDefault(); &#125;&#125;, false); 相关链接：disable viewport zooming iOS 10 safari? webview相关Cache开启和设置browser.getSettings().setAppCacheEnabled(true); browser.getSettings().setAppCachePath(&quot;/data/data/[com.packagename]/cache&quot;); browser.getSettings().setAppCacheMaxSize(5*1024*1024); // 5MB LocalStorage相关设置browser.getSettings().setDatabaseEnabled(true); browser.getSettings().setDomStorageEnabled(true); String databasePath = browser.getContext().getDir(&quot;databases&quot;, Context.MODE_PRIVATE).getPath(); browser.getSettings().setDatabasePath(databasePath);//Android webview的LocalStorage有个问题，关闭APP或者重启后，就清楚了，所以需要browser.getSettings().setDatabase相关的操作，把LocalStoarge存到DB中 myWebView.setWebChromeClient(new WebChromeClient(){ @Override public void onExceededDatabaseQuota(String url, String databaseIdentifier, long currentQuota, long estimatedSize, long totalUsedQuota, WebStorage.QuotaUpdater quotaUpdater) { quotaUpdater.updateQuota(estimatedSize * 2); } } 浏览器自带缩放按钮取消显示browser.getSettings().setBuiltInZoomControls(false); 几个比较好的实践使用localstorage缓存html 使用lazyload，还要记得lazyload占位图虽然小，但是最好能提前加载到缓存 延时加载执行js 主要原因就在于Android Webview的onPageFinished事件，Android端一般是用这个事件来标识页面加载完成并显示的，也就是说在此之前，会一直loading，但是Android的OnPageFinished事件会在Javascript脚本执行完成之后才会触发。如果在页面中使用JQuery，会在处理完DOM对象，执行完$(document).ready(function() {});事件自会后才会渲染并显示页面。 manifest与缓存相关:http://www.alloyteam.com/2013/12/web-cache-6-hybrid-app-tailored-cache/相关解决方案http://mt.tencent.com/ 移动端调适篇手机抓包与配host在PC上，我们可以很方便地配host，但是手机上如何配host，这是一个问题。 这里主要使用fiddler和远程代理，实现手机配host的操作，具体操作如下： 首先，保证PC和移动设备在同一个局域网下； PC上开启fiddler，并在设置中勾选“allow remote computers to connect” 首先，保证PC和移动设备在同一个局域网下； PC上开启fiddler，并在设置中勾选“allow remote computers to connect” 手机上设置代理，代理IP为PC的IP地址，端口为8888（这是fiddler的默认端口）。通常手机上可以直接设置代理，如果没有，可以去下载一个叫ProxyDroid的APP来实现代理的设置。 此时你会发现，用手机上网，走的其实是PC上的fiddler，所有的请求包都会在fiddler中列出来，配合willow使用，即可实现配host，甚至是反向代理的操作。 也可以用CCProxy之类软件，还有一种方法就是买一个随身wifi，然后手机连接就可以了！ 高级抓包iPhone上使用Burp Suite捕捉HTTPS通信包方法 mobile app 通信分析方法小议（iOS/Android) 实时抓取移动设备上的通信包(ADVsock2pipe+Wireshark+nc+tcpdump) 静态资源缓存问题一般用代理软件代理过来的静态资源可以设置nocache避免缓存，但是有的手机比较诡异，会一直缓存住css等资源文件。由于静态资源一般都是用版本号管理的，我们以charles为例子来处理这个问题 charles 选择静态的html页面文件-saveResponse。之后把这个文件保存一下，修改一下版本号。之后继续发请求，刚才的html页面文件 右键选择 –map local 选择我们修改过版本号的html文件即ok。这其实也是fiddler远程映射并修改文件的一个应用场景。 安卓模拟器和真机区别http://www.farsight.com.cn/news/emb105.htm http://testerhome.com/topics/388 http://www.cnblogs.com/zdz8207/archive/2012/01/30/2332436.html 移动浏览器篇微信浏览器微信浏览器的调试技巧http://www.html-js.com/article/WeChat-cock-burst-perfect-debugging-WeChat-WebView-x5%203076 微信浏览器的各种bug汇总 （x5内核） http://www.qianduan.net/qqliu-lan-qi-x5nei-he-wen-ti-hui-zong/ 因为微信浏览器屏蔽了一部分链接图片，所以需要引导用户去打开新页面，可以用以下方式判断微信浏览器的ua function is_weixn(){ var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==&quot;micromessenger&quot;) { return true; } else { return false; } } 后端判断也很简单，比如php function is_weixin(){ if ( strpos($_SERVER[&apos;HTTP_USER_AGENT&apos;], &apos;MicroMessenger&apos;) !== false ) { return true; } return false; } https://github.com/maxzhang/maxzhang.github.com/issues/31 微信浏览器踩坑，来自maxZhang https://github.com/maxzhang ###【UC浏览器】video标签脱离文档流 场景：标签的父元素(祖辈元素)设置transform样式后，标签会脱离文档流。 测试环境：UC浏览器 8.7/8.6 + Android 2.3/4.0 。 Demo：http://t.cn/zj3xiyu 解决方案：不使用transform属性。translate用top、margin等属性替代。 ###【UC浏览器】video标签总在最前 场景：标签总是在最前（可以理解为video标签的z-index属性是Max）。 测试环境：UC浏览器 8.7/8.6 + Android 2.3/4.0 。 ###【UC浏览器】position:fixed 属性在UC浏览器的奇葩现象 场景：设置了position: fixed 的元素会遮挡z-index值更高的同辈元素。 在8.6的版本,这个情况直接出现。 在8.7之后的版本,当同辈元素的height大于713这个「神奇」的数值时,才会被遮挡。 测试环境：UC浏览器 8.8_beta/8.7/8.6 + Android 2.3/4.0 。 Demo：http://t.cn/zYLTSg6 ###【UC浏览器】rem 不能正确计算的问题 场景：使用以下代码，横竖屏操作后，rem并没有被重新计算，一开始以为是页面没有重绘，强制重绘页面后，发现问题并没有解决。 12345678910111213(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 100 * (clientWidth / 320) + 'px'; &#125;; recalc(); if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 测试环境：UC浏览器 V10.9 + Android 6.0+ 。 解决方案：手动在head中插入style，给html设置font-size,并使用 !important 增加优先级，123456789101112131415161718192021(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; var style; if(style=document.getElementById(\"hackUcRem\"))&#123; style.parentNode.removeChild(style); &#125; style = document.createElement(\"style\"); style.id=\"hackUcRem\"; document.head.appendChild(style); style.appendChild(document.createTextNode(\"html&#123;font-size:\" + 100 * (clientWidth / 320) + \"px !important;&#125;\")); docEl.style.fontSize = 100 * (clientWidth / 320) + 'px'; &#125;; recalc(); if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); ###【QQ手机浏览器】不支持HttpOnly 场景：带有HttpOnly属性的Cookie，在QQ手机浏览器版本从4.0开始失效。JavaScript可以直接读取设置了HttpOnly的Cookie值。 测试环境：QQ手机浏览器 4.0/4.1/4.2 + Android 4.0 。 ###【MIUI原生浏览器】浏览器地址栏hash不改变 场景：location.hash 被赋值后，地址栏的地址不会改变。 但实际上 location.href 已经更新了，通过JavaScript可以顺利获取到更新后的地址。 虽然不影响正常访问，但用户无法将访问过程中改变hash后的地址存为书签。 测试环境：MIUI 4.0 ###【Chrome Mobile】fixed元素无法点击 场景：父元素设置position: fixed; 子元素设置position: absolute; 此时，如果父元素/子元素还设置了overflow: hidden 则出现“父元素遮挡该子元素“的bug。 视觉(view)层并没有出现遮挡，只是无法触发绑定在该子元素上的事件。可理解为：「看到点不到」。 补充： 页面往下滚动，触发position: fixed;的特性时，才会出现这个bug，在最顶不会出现。 测试平台： 小米1S，Android4.0的Chrome18 demo： http://maplejan.sinaapp.com/demo/fixed_chromemobile.html 解决办法： 把父元素和子元素的overflow: hidden去掉。 以上来源于 http://www.cnblogs.com/maplejan/archive/2013/04/26/3045928.html 库的使用实践zepto.js zepto的一篇使用注意点讲解 zepto的著名的tap“点透”bug zepto源码注释 使用zeptojs内嵌到android webview影响正常滚动时https://github.com/madrobby/zepto/blob/master/src/touch.js 去掉61行,其实就是使用原生的滚动 iscroll4 iscroll4 的几个bug(来自 http://www.mansonchor.com/blog/blog_detail_64.html 内有详细讲解) 1.滚动容器点击input框、select等表单元素时没有响应】 onBeforeScrollStart: function (e) { e.preventDefault(); } 改为 onBeforeScrollStart: function (e) { var nodeType = e.explicitOriginalTarget © e.explicitOriginalTarget.nodeName.toLowerCase():(e.target © e.target.nodeName.toLowerCase():&apos;&apos;);if(nodeType !=&apos;select&apos;&amp;&amp; nodeType !=&apos;option&apos;&amp;&amp; nodeType !=&apos;input&apos;&amp;&amp; nodeType!=&apos;textarea&apos;) e.preventDefault(); } 2.往iscroll容器内添加内容时，容器闪动的bug 源代码的 has3d = &apos;WebKitCSSMatrix&apos; in window &amp;&amp; &apos;m11&apos; in new WebKitCSSMatrix() 改成 has3d = false 在配置iscroll时，useTransition设置成false 3.过长的滚动内容，导致卡顿和app直接闪退 不要使用checkDOMChanges。虽然checkDOMChanges很方便，定时检测容器长度是否变化来refresh，但这也意味着你要消耗一个Interval的内存空间 隐藏iscroll滚动条，配置时设置hScrollbar和vScrollbar为false。 不得已的情况下，去掉各种效果，momentum、useTransform、useTransition都设置为false 4.左右滚动时，不能正确响应正文上下拉动 iscroll的闪动问题也与渲染有关系，可以参考 运用webkit绘制渲染页面原理解决iscroll4闪动的问题iscroll4升级到5要注意的问题 iscroll或者滚动类框架滚动时不点击的方法可以使用以下的解决方案(利用data-setapi) &lt;a ontouchmove=&quot;this.s=1&quot; ontouchend=&quot;this.s || window.open(this.dataset.href),this.s=0&quot; target=&quot;_blank&quot; data-href=&quot;http://www.hao123.com/topic/pig&quot;&gt;黄浦江死猪之谜&lt;/a&gt; 也可以用这种方法 $(document).delegate(&apos;[data-target]&apos;, &apos;touchmove&apos;, function () { $(this).attr(&apos;moving&apos;,&apos;moving&apos;); }) $(document).delegate(&apos;[data-target]&apos;, &apos;touchend&apos;, function () { if ($(this).attr(&apos;moving&apos;) !== &apos;moving&apos;) { //做你想做的。。 $(this).attr(&apos;moving&apos;, &apos;notMoving&apos;); } else { $(this).attr(&apos;moving&apos;, &apos;notMoving&apos;); } }) 移动端字体问题知乎专栏 - [无线手册-4] dp、sp、px傻傻分不清楚[完整] Resolution Independent Mobile UI Pixel density, retina display and font-size in CSS Device pixel density tests 跨域问题手机浏览器也是浏览器，在ajax调用外部api的时候也存在跨域问题。当然利用 PhoneGap 打包后，由于协议不一样就不存在跨域问题了。但页面通常是需要跟后端进行调试的。一般会报类似 XMLHttpRequest cannot load XXX Origin null is not allowed by Access-Control-Allow-Origin. 以及 XMLHttpRequest cannot load http://. Request header field Content-Type is not allowed by Access-Control-Allow-Headers.&quot; 这时候可以让后端加上两个http头 Access-Control-Allow-Origin &quot;*&quot; Access-Control-Allow-Headers &quot;Origin, X-Requested-With, Content-Type, Accept&quot; 第一个头可以避免跨域问题，第二个头可以方便ajax请求设置content-type等配置项 这个会存在一些安全问题，可以参考这个问题的讨论 http://www.zhihu.com/question/22992229","categories":[{"name":"前端规范","slug":"前端规范","permalink":"https://syhyz1990.github.io/categories/前端规范/"}],"tags":[]},{"title":"CSS初始化样式","slug":"css-reset","date":"2017-12-09T06:05:33.000Z","updated":"2018-06-05T08:22:01.003Z","comments":true,"path":"wiki/css-reset.html","link":"","permalink":"https://syhyz1990.github.io/wiki/css-reset.html","excerpt":"","text":"PC端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341/*! normalize.css v8.0.0 | MIT License | github.com/necolas/normalize.css *//* Document ========================================================================== *//** * 1. Correct the line height in all browsers. * 2. Prevent adjustments of font size after orientation changes in iOS. */html &#123; line-height: 1.15; /* 1 */ -webkit-text-size-adjust: 100%; /* 2 */&#125;/* Sections ========================================================================== *//** * Remove the margin in all browsers. */body &#123; margin: 0;&#125;/** * Correct the font size and margin on `h1` elements within `section` and * `article` contexts in Chrome, Firefox, and Safari. */h1 &#123; font-size: 2em; margin: 0.67em 0;&#125;/* Grouping content ========================================================================== *//** * 1. Add the correct box sizing in Firefox. * 2. Show the overflow in Edge and IE. */hr &#123; box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */&#125;/** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */pre &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/* Text-level semantics ========================================================================== *//** * Remove the gray background on active links in IE 10. */a &#123; background-color: transparent;&#125;/** * 1. Remove the bottom border in Chrome 57- * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari. */abbr[title] &#123; border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */&#125;/** * Add the correct font weight in Chrome, Edge, and Safari. */b,strong &#123; font-weight: bolder;&#125;/** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */code,kbd,samp &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/** * Add the correct font size in all browsers. */small &#123; font-size: 80%;&#125;/** * Prevent `sub` and `sup` elements from affecting the line height in * all browsers. */sub,sup &#123; font-size: 75%; line-height: 0; position: relative; vertical-align: baseline;&#125;sub &#123; bottom: -0.25em;&#125;sup &#123; top: -0.5em;&#125;/* Embedded content ========================================================================== *//** * Remove the border on images inside links in IE 10. */img &#123; border-style: none;&#125;/* Forms ========================================================================== *//** * 1. Change the font styles in all browsers. * 2. Remove the margin in Firefox and Safari. */button,input,optgroup,select,textarea &#123; font-family: inherit; /* 1 */ font-size: 100%; /* 1 */ line-height: 1.15; /* 1 */ margin: 0; /* 2 */&#125;/** * Show the overflow in IE. * 1. Show the overflow in Edge. */button,input &#123; /* 1 */ overflow: visible;&#125;/** * Remove the inheritance of text transform in Edge, Firefox, and IE. * 1. Remove the inheritance of text transform in Firefox. */button,select &#123; /* 1 */ text-transform: none;&#125;/** * Correct the inability to style clickable types in iOS and Safari. */button,[type=\"button\"],[type=\"reset\"],[type=\"submit\"] &#123; -webkit-appearance: button;&#125;/** * Remove the inner border and padding in Firefox. */button::-moz-focus-inner,[type=\"button\"]::-moz-focus-inner,[type=\"reset\"]::-moz-focus-inner,[type=\"submit\"]::-moz-focus-inner &#123; border-style: none; padding: 0;&#125;/** * Restore the focus styles unset by the previous rule. */button:-moz-focusring,[type=\"button\"]:-moz-focusring,[type=\"reset\"]:-moz-focusring,[type=\"submit\"]:-moz-focusring &#123; outline: 1px dotted ButtonText;&#125;/** * Correct the padding in Firefox. */fieldset &#123; padding: 0.35em 0.75em 0.625em;&#125;/** * 1. Correct the text wrapping in Edge and IE. * 2. Correct the color inheritance from `fieldset` elements in IE. * 3. Remove the padding so developers are not caught out when they zero out * `fieldset` elements in all browsers. */legend &#123; box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */&#125;/** * Add the correct vertical alignment in Chrome, Firefox, and Opera. */progress &#123; vertical-align: baseline;&#125;/** * Remove the default vertical scrollbar in IE 10+. */textarea &#123; overflow: auto;&#125;/** * 1. Add the correct box sizing in IE 10. * 2. Remove the padding in IE 10. */[type=\"checkbox\"],[type=\"radio\"] &#123; box-sizing: border-box; /* 1 */ padding: 0; /* 2 */&#125;/** * Correct the cursor style of increment and decrement buttons in Chrome. */[type=\"number\"]::-webkit-inner-spin-button,[type=\"number\"]::-webkit-outer-spin-button &#123; height: auto;&#125;/** * 1. Correct the odd appearance in Chrome and Safari. * 2. Correct the outline style in Safari. */[type=\"search\"] &#123; -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */&#125;/** * Remove the inner padding in Chrome and Safari on macOS. */[type=\"search\"]::-webkit-search-decoration &#123; -webkit-appearance: none;&#125;/** * 1. Correct the inability to style clickable types in iOS and Safari. * 2. Change font properties to `inherit` in Safari. */::-webkit-file-upload-button &#123; -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */&#125;/* Interactive ========================================================================== *//* * Add the correct display in Edge, IE 10+, and Firefox. */details &#123; display: block;&#125;/* * Add the correct display in all browsers. */summary &#123; display: list-item;&#125;/* Misc ========================================================================== *//** * Add the correct display in IE 10+. */template &#123; display: none;&#125;/** * Add the correct display in IE 10. */[hidden] &#123; display: none;&#125; 移动端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed,figure, figcaption, footer, header,menu, nav, output, ruby, section, summary,time, mark, audio, video, input margin: 0 padding: 0 border: 0 font-size: 100% font-weight: normal vertical-align: baseline/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure,footer, header, menu, nav, section display: blockbody line-height: 1blockquote, q quotes: noneblockquote:before, blockquote:after,q:before, q:after content: nonetable border-collapse: collapse border-spacing: 0/* custom */a color: #7e8c8d -webkit-backface-visibility: hidden text-decoration: noneli list-style: nonebody -webkit-text-size-adjust: none -webkit-tap-highlight-color: rgba(0, 0, 0, 0)","categories":[{"name":"代码片段","slug":"代码片段","permalink":"https://syhyz1990.github.io/categories/代码片段/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://syhyz1990.github.io/tags/CSS/"}]},{"title":"PHP类库","slug":"php-class","date":"2017-06-20T09:20:03.000Z","updated":"2018-06-05T08:59:09.719Z","comments":true,"path":"wiki/php-class.html","link":"","permalink":"https://syhyz1990.github.io/wiki/php-class.html","excerpt":"","text":"收集整理一些常用的PHP类库, 资源以及技巧. 以便在工作中迅速的查找所需… 这个列表中的内容有来自 awesome-php 的翻译, 有来自开发者周刊以及个人的积累等. 学习资源 PHP相关的有参考价值的社区,博客,网站,文章,书籍,视频等资源 PHP网站(PHP Websites) PHP The Right Way - 一个PHP实践的快速参考指导 PHP Best Practices - 一个PHP最佳实践 Clean Code PHP - 一个PHP 编码标准 PHP Weekly News - 一个PHP 周刊 Securing PHP - 有关PHP安全相关 PHP FIG - PHP框架交互小组 PSR 中文翻译 PHP School - 一个开源的PHP学习资源 PHPTrends - 一些快速发展的PHP类库检索 PHP 开发者实践 推荐文章(Recommended Article) The 2018 Guide to Building Secure PHP Software 中文翻译: 2018 PHP 应用程序安全设计指北 advanced-php - PHP多进程、socket等相关文章 其他网站(Other Websites) The Open Web Application Security Project (OWASP) - 一个开源软件安全社区 WebSec IO - 一个web 安全社区 Semantic Versioning - 语义化版本 Atlassian Git Tutorials - 一系列的Git教程 Servers for Hackers - 有关服务器运维相关 be-a-professional-programmer - 成为专业程序员路上用到的各种优秀资料、神器及框架 PHP书籍(PHP Books) Modern PHP - 作者是PHP 之道的发起人和Slim框架的作者 Modern PHP（中文版） PHP Pandas ppts_for_php2017 - 2017 第三届PHP全球开发者大会PPT/Keynote PHP-Data-Structure-and-Algorithms 其他书籍(Other Books) The Linux Command Line - Linux 命令行教程 architecture.of.internet-product - 互联网公司技术架构 architect-awesome - 后端架构师技术图谱 依赖管理( Dependency Management ) 用于依赖管理的包和框架 Composer / Packagist - 一个包和依赖管理器. Composer Installers - 一个多框架Composer库安装器 pickle - PHP扩展安装器 Melody - A tool to build one file Composer scripts. 框架( Frameworks ) Web开发框架 Symfony2 - 由独立组件构成的框架(SP2) Zend Framework 2 - 同样是由独立组件构成的框架(ZF2) Laravel 5 - 简洁优雅的PHP Web开发框架(L5) Aura PHP - 独立组件的框架 Yii2 - 用于开发大型Web应用的高性能PHP框架 Nette - 同样是由独立组件构成的框架 PPI Framework 2 - 一个交互性的框架 CakePHP - 一个高效的应用开发框架(CP) Phalcon - 一个作为C扩展的框架 Yaf - 鸟哥的C扩展的框架 swoole-yaf - 基于 Swoole 及 Yaf 的开发框架 yaf - 另一个基于 Swoole 及 Yaf 的开发框架 SwooleDistributed - swoole 分布式全栈框架 Zan PHP Framework - 有赞开源的 PHP 框架 php-msf - Camera360开源的微服务框架 Biny - Biny是一款高性能的超轻量级PHP框架 Swoft Framework - 基于Swoole原生协程，新时代PHP高性能协程框架 组件( Components ) Aura Components - 一个PHP5.4的组件包 Hoa Project - 一个PHP组件集合 配置( Configuration ) 加载配置文件的类库和扩展 Yaconf - 一个高性能的配置管理扩展 config - 一个轻量级的配置加载器, 支持 PHP, INI, XML, JSON, YAML files Zend-config phpdotenv - 读取.env中全局的最高优先级变量 微框架( Micro Frameworks ) 微型框架和路由 Silex - 基于Symphony2组件的微型框架 Silex Skeleton - 用于Silex的项目框架 Silex Web Profiler - 用于Silex的Web调试工具条 Slim - 另一个简单的微型框架 awesome-slim Slim Skeleton - 用于Slim的框架 Slim View - Slim的自定义视图集 Slim Middleware - Slim的自定义中间件集合 slim-skeleton - Slim基础上实现了MVC及一些组件 slim-boilerplate Bullet PHP - 用于构建REST APIs的微型框架 Lumen - 基于Laravel的微型框架 Proton - 一个微型PHP框架 blink - 一个为构建 “long running” 服务而生的 Web 微型高性能框架 路由( Routers ) Fast Route - 一个高效路由库 Route - 基于Fast Route的路由库 Pux - 另一个高效的路由库 Klein - 一个灵活的路由库 Macaw - 一个简单的 PHP 路由器，超级精简、快速而且很性感。 模板引擎( Templating ) 模板和词法分析的库与工具 Twig - 一种综合的模板语言 Twig Cache Extension - 用于Twig的模板片段缓存库 Mustache - PHP实现的Mustache模板语言 Phly Mustache - 另一个PHP实现的Mustache模板语言 MtHaml - PHP实现的HAML模板语言 PHPTAL - PHP实现的TAL模板语言 Plates - 一个原始的PHP模板库 Lex - 一个轻量级模板解析器 Aura.View - Provides TemplateView and TwoStepView 静态站生成器( Static Site Generators ) 生成Web页面内容的预处理工具 Sculpin - 将Markdown和Twig转换为静态HTML的工具 Phrozn - 另一款ithub将Textile、Markdown和Twig转为HTML的工具 Spress Couscous - 将Markdown 文档转换成 HTML 发布到Github Page 的工具 HTTP 用于HTTP和抓取网站的库 Guzzle - 一个完整的HTTP客户端 Buzz - 另一个HTTP客户端 Requests - 一个简单的HTTP库 HTTPFul - 一个链式HTTP客户端 Goutte - 一个简单的Web抓取器 PHP VCR - 一个录制和回放HTTP请求的库 php-curl-class - PHP的Curl类 Beanbun - 多进程网络爬虫框架 php-mod/curl - PHP Curl Class SOAP soap-client - A general purpose SOAP client for PHP soap-client - PHP implementation of SOAP 1.1 and 1.2 client specifications wsdl2phpgenerator - Simple utility and class library for generating php classes from a wsdl file. 中间件( Middlewares ) 用于构建应用的类库的中间件 URL 解析URL的库 Purl - 一个URL操作库 PHP Domain Parser - 一个本地的后缀解析器 Uri - 一个简单的URL操作库 邮件( Email ) 用于发送和解析Email的库 SwiftMailer - 一个邮件程序的解决方案 PHPMailer - 另一个邮件程序的解决方案 Nette Mail - 一个简单优雅的邮件发送模块 Fetch - 一个IMAP库 Email Reply Parser - 一个邮件回复解析器库 Stampie - 关于邮件服务的库，比如SendGrid、PostMark、MailGun和Mandrill CssToInlineStyles - 邮件模板中一个内联的CSS库 Email Validator - 一个小巧的邮箱验证库 文件操作( Files ) 关于文件处理和MIME类型检查 Gaufrette - 一个文件流的抽象层 Flysystem - 另一个文件流的抽象层 Canal - 一个检查互联网媒体类型的库 Apache MIME Types - 一个解析Apache MIME类型的库 Ferret - 一个MIME检测库 Hoa Mime - 另一个MIME检测库 Lurker - 一个资源跟踪库 PHP File Locator - 一个在大型项目中定位文件的库 PHP FFmpeg - 一个用于FFmpeg视频包装的库 CSV - 一个CSV数据操作库 流( Stream ) 处理流的库 Streamer - 一个简单的面向对象流包装库 依赖注入( Dependency Injection ) 实现依赖注入设计模式的库 Pimple - 一个小的依赖注入容器 container-interop - Containers interoperability Auryn - 另一个小的依赖注入容器 Container - 另一个灵活的依赖注入容器 PHP DI - 一个使用标注实现的依赖注入 Acclimate - 依赖注入容器和服务定位器的通用接口 Symfony DI - 一个的依赖注入组件(SF2) Twittee simple di container Ding di - Yii DI container and injector 图像( Imagery ) 处理图像的库 Imagine - 一个图像处理库 PHP Image Workshop - 另一个图像处理库 Intervention Image - 同样还是一个图像处理库 GIF Frame Extractor - 一个提取GIF动画帧信息的库 GIF Creator - 从多幅图片中创建GIF动画的库 Image With Text - 在图像中嵌入文本的库 Color Extractor - 从图像中提取颜色的库 Glide - 一个按需的图片处理库 Image Optimizer - 一个优化图片的库 PHPThumb - 缩略图处理库 phpqrcode - 二维码生成库 QrCode - 另一个二维码生成库 pel - PHP Exif 库 php-exif - PHP Exif信息读取库 Captcha - 图形验证码 测试( Testing ) 测试代码库和生成测试数据的库 PHPUnit - 一个单元测试框架 DBUnit - PHPUnit的代码测试库 ParaTest - PHPUnit的并行测试库 PHPSpec - 根据规范的单元测试库 Codeception - 一个全栈测试框架 AspectMock - PHPUnit/Codeception的模拟框架 Atoum - 一个简单的测试库 Mockery - 一个用于测试的模拟对象库 Phake - 另一个用于测试的模拟对象库 Prophecy - 一个强大的模拟框架 Faker - 一个伪数据生成库 Samsui - 另一个伪数据生成库 Alice - 用于生成复杂数据的库 Behat - 一个行为驱动开发（BDD）的测试框架 Pho - 另一个行为驱动开发的测试框架 Mink - Web验收测试 HTTP Mock - 一个在单元测试中模拟HTTP请求的库 VFS Stream - 一个用于测试的虚拟文件系统流包装 VFS - 另一个用于测试的虚拟文件系统 Locust - 一个Python开发的现代负载测试库 Peridot - 一个事件驱动的测试框架 SimpleTest - Unit Testing for PHP 持续集成( Continuous Integration ) 持续集成的库和应用 Travis CI - 一个持续集成的平台 SemaphoreCI - 一个给开源程序和私有项目的持续集成平台 PHPCI - 一个PHP的开源持续集成平台 Sismo - 一个持续的测试服务器库 Jenkins - PHP支持的持续集成平台 JoliCi - PHP开发的由Docker支持的持续集成客户端 文档( Documentation ) 生成项目文档的库 Sami - 一个API文档生成器 APIGen - 另一个API文档生成器 PHP Documentor 2 - 文档生成器 phpDox - 一个PHP项目的文档生成器（不仅仅是API文档） swagger-php - A php swagger annotation and parsing library 安全( Security ) 用于生成安全的随机数、加密数据、扫描漏洞, 令牌的库 HTML Purifier - 一个标准的HTML过滤器 random_compat - PHP5.x生成安全的随机数的库(PHP7可用内置random_bytes()和random_int()函数) RandomLib - 生成随机数和随机字符串的库 True Random - 使用www.random.org生成随机数的库 SecurityMultiTool - 一个PHP安全库 PHPSecLib - 一个纯的PHP安全通信库 TCrypto - 一个简单的键值加密存储库 PHP IDS - 一个结构化的PHP安全层 PHP SSH - 面向对象的SSH包装库 IniScan - 一个扫描PHP INI文件安全的工具 SensioLabs Security Check - 一个根据安全建议检查Composer依赖的Web工具 Zed - 用于Web应用的集成渗透测试工具 php-ratelimiter xxtea-php - XXTEA encryption algorithm library for PHP. 密码( Passwords ) 处理和存储密码的库和工具、各种编码的库 Password Compat - 一个用于新的PHP5.5密码功能的兼容库 phpass - 一个便携式密码哈希框架 PHP Password Lib - 一个用于生成和验证密码的库 Password Policy - 一个PHP和JavaScript的密码规则库 Password Validator - 验证和升级密码哈希的库 Zxcvbn PHP - 一个基于Zxcvbn JS的PHP显示密码强度估计库 GenPhrase - 一个生成安全随机口令的库 base62 - base62编码库(短网址应用) base58php - base58编码库(Bitcoin中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址) base85 - base85编码库(在base64的基础上进一步压缩数据量,应用于Adobe的PostScript语言和PDF文档格式) 代码分析( Code Analysis ) 用于分析、解析和操作代码库的工具 PHP Parser - 一个PHP编写的PHP解析器 PHPPHP - 一个PHP实现的PHP虚拟机 PHPSandbox - PHP的沙盒环境 Dissect - 词法和语法分析的工具集合 PHP Mess Detector - 一个扫描代码bug、次佳代码和未使用参数的库 PHP Code Sniffer - 一个检测PHP、CSS和JS代码标准冲突的库 PHPCPD - 一个检测复制和粘贴代码的库 PHP Analyser - 一个分析PHP代码中错误的库 PHP CS Fixer - 一个代码标准库 PHP Manipulator - 用于分析和修改PHP源代码的库 PHP Metrics - 一个静态测量库 PHP Refactoring Browser - 一个用于重构PHP代码的命令行工具 php-semver-checker - 一个版本对比的命令行工具 UBench - 一个简单的小型基准测试库 Athletic - 一个基于标注的基准测试库 Mondrian - 使用图论的代码分析工具 Scrutinizer - 检查PHP代码的Web工具 PHPLOC - 一个快速评估PHP项目大小的工具 PHPCheckstyle - 一个帮助遵守特定代码规则的工具 PhpDependencyAnalysis - 一个创建可定制型依赖关系图表的工具 Code Climate - 自动化的code review PHP Error - 用于转换标准的 PHP 错误信息，主要用于开发过程中的调试 psalm - 一个帮助你识别代码里可能存在 bugs 的静态分析工具 phan - 代码静态分析工具 phpstan - 代码静态分析工具 结构( Architectural ) 有关于设计模式,编程规范以及代码组织方式的库 PHP Option - 一个PHP选项类型的库 Ruler - 一个简单的无状态的产生环境规则的引擎 Finite - 一个简单的PHP有限状态机 Compose - 一个功能组合库 Monad PHP - 一个简单Monad库 Patchwork - 一个重新定义用户的函数库 Galapagos - 语言转换进化 Design Patterns PHP - 一个使用PHP实现的设计模式实例库 Functional PHP - 一个函数式编程库 Lib Accessor - 一个简化访问的库 Iter - 一个使用生成器提供迭代原语的库 调试和性能( Debugging and Profiling ) 调试代码的库和工具 xDebug - 一个PHP的调试和分析工具 whoops PHP Debug Bar - 一个调试工具条 PHP Console - Web调试控制台 Barbushin PHP Console - 一个使用Google Chrome的Web调试控制工具 PHPDBG - 一个交互性的PHP调试器 Tracy - 一个简单的错误检测、日志和时间测量库 Z-Ray - 一个调试和性能分析的工具 xHprof - Facebook开源的PHP性能评测工具 xhprof - 基于官方版本fork的社区版本(支持PHP7) xhprof.io - 实现保存xhprof数据以及展示数据的UI xhgui - 另一个保存xhprof数据以及展示数据的UI Blackfire.io - 一个低开销的代码探查器 Kint - 一个调试和性能分析的工具 phptrace - 360开源的PHP执行跟踪工具 php-apm - Application performance management for PHP application BooBoo - 集中异常捕获 Collision - 命令行PHP应用程序的错误处理程序框架 symfony/debug - PHP debug调试库 构建工具( Build Tools ) 项目构建和自动化工具 Go - 一个简单的PHP构建工具 Bob - 一个简单的项目自动化工具 Phake - 一个PHP克隆库 Box - 用来构建PHAR文件的工具 Phing - 依据Apache Ant的PHP项目构建系统 任务运行器( Task Runners ) 自动运行任务的库 Task - 依据Grunt和Gulp的纯PHP任务运行器 Robo - 面向对象的PHP任务运行器 Bldr - 构建在Symfony组件上的PHP任务运行器 导航( Navigation ) 构建导航结构的工具 KnpMenu - 一个菜单库 Cartographer - 一个站点地图生成库 资源管理( Asset Management ) 用于管理、压缩和最小化网站资源的工具 Assetic - 一个资源管理的管道库 Pipe - 另一个资源管理的管道库 Munee - 一个资源优化库 JShrink - 一个JavaScript的压缩库 Puli - 一个检测资源绝对路径的库 地理定位( Geolocation ) 使用经纬度编码地址的库 GeoCoder - 一个地理编码库 GeoTools - 一个地理工具相关的库 PHPGeo - 一个简单的地理库 GeoJSON - 一个GeoJSON的实现 日期与时间( Date and Time ) 处理日期和时间的库 Carbon - 一个简单的日期时间API扩展 ExpressiveDate - 另一个日期时间API扩展 CalendR - 一个日历管理的库 date - 一个多语言的日期库 moment.php 事件( Event ) 事件驱动或非阻塞事件循环实现的库 React - 一个事件驱动的非阻塞I/O库 Rx.PHP - 一个反应扩展库 phpsocket.io Ratchet - 一个Web套接字库 Hoa WebSocket - 另一个Web套接字库 Elephant.io - 另一个Web套接字库 Hoa EventSource - 一个事件源库 Evenement - 一个事件调度库 Event - Event package for your app and/or domain. Cake Event - 一个事件调度类库 Broadway - 一个事件源和CQRS库 日志( Logging ) 用于生成和处理日志文件的库 Monolog - 一个综合的日志类库 KLogger - 一个易于使用的PSR-3日志类 Analog - 一个机遇闭包的微型日志包 SeasLog - 一个高效的日志扩展 电子商务( E-commerce ) 用于支付和构建在线电子商务商店的库和应用 OmniPay - 一个多网关支付处理的框架 omnipay-paypal - PayPal 支付 omnipay-wechatpay - 微信支付 omnipay-unionpay - 银联支付 omnipay-alipay - 支付宝支付 omnipay-pingpp - ping++聚合支付 omnipay-99bill - 快钱支付 Payum - 一个用于支付的抽象库 Sylius - 一个开源的电子商务解决方案 Thelia - 另一个开源的电子商务解决方案 Money - PHP实现的Fowler金钱模式 Sebastian Money - 一个处理货币价值的库 Swap - 一个汇率库 PDF 处理PDF文件的库和软件 Snappy - 一个PDF和图像的生成库 WKHTMLToPDF - 一个将HTML转换为PDF的工具 PHPPdf - 一个将XML转化为PDF和图片的库 phpwkhtmltopdf php-pdftk - A PDF conversion and form utility based on pdftk Office Office套装的各种文档的处理库 PHPWord - 处理Word文档的库 PHPExcel - 处理Excel文档的库 PHPPowerPoint - 处理PPT幻灯片的库 ExcelAnt - 操作Excel文档的库 PhpSpreadsheet - 建议使用最新的PHPOffice维护的Excel 文档处理库 php-ext-excel-export - 操作Excel的 PHP 扩展 数据库( Database ) 使用对象关系映射（ORM）或数据映射技术的数据库交互库 Doctrine - 一个完整的DBAL和ORM Doctrine Extensions - 一个Doctrine行为的扩展集合 Propel - 一个快速的ORM，迁移和查询库 Eloquent - Laravel 5 ORM(L5) LazyRecord - 一个快速的ORM Baum - 一个Eloquent的嵌套集合 Spot2 - MySQL的ORM映射器 RedBean - 一个轻量级、易配置的ORM Pomm - 用于PostgreSQL的一个对象模型管理器 ProxyManager - 用于数据映射生成代理对象的工具集合 Cake ORM - 对象关系映射器, 实现了使用数据映射模式(CP) Medoo - 一个轻量级的加速开发的ORM Aura SQL - SQL database access through PDO. EasyDB - 数据库抽象层 迁移( Migrations ) 用于管理数据库模式和迁移的库 PHPMig - 一个迁移管理库 Phinx - 一个数据库迁移管理库 Migrations - 另一个迁移管理库 Doctrine Migrations - 用于Doctrine的迁移库 非关系型数据库( NoSQL ) 处理NoSQL后端的库 MongoDB mongo-php-library - MongoDB 官方PHP库 MongoQB - 一个MongoDB的查询构建库 Monga - 一个MongoDB的抽象库 mongodm - MongoDB ORM php-mongo - PHP ODM for MongoDB laravel-mongodb Redis Predis - 一个功能完全的Redis库 codis - Codis 是一个分布式 Redis 解决方案 twemproxy - 是twtter开源的一个redis和memcache代理服务器 pika - Pika是一个可持久化的大容量redis存储服务 队列( Queue ) 处理事件和任务队列的库 enqueue-dev - Message queue packages for PHP, Symfony, Laravel, Magento enqueue/rdkafka enqueue/enqueue enqueue/pheanstalk enqueue/redis 队列服务框架 Kafka - 高吞吐量的分布式发布订阅消息系统 RabbitMQ - 使用 erlang 编写的 AMQP (高级消息队列协议) 的服务实现 RocketMQ ActiveMQ Qpid Disque - 分布式内存队列 beanstalkd - 一个高性能、轻量级的消息队列中间件 队列相关类库 Pheanstalk - 一个Beanstalkd客户端库 PHP AMQP - 一个纯PHP AMQP库 Thumper - 一个RabbitMQ模式库 Bernard - 一个多后端的抽象库 php-resque - 基于redis的消息队列 php-amqplib - 一个RabbitMQ客户端库 kafka-php - 一个kafka客户端库(Composer) php-rdkafka - 一个kafka客户端库(PECL) 搜索( Search ) 在数据中建立索引和执行查询相关的库和软件 ElasticSearch PHP - 用于 ElasticSearch 的官方客户端库. Elastica - 另一个ElasticSearch的客户端库 Solarium - Solr 的客户端库 . SphinxQL query builder - Sphinx 搜索引擎的查询库 命令行( Command Line ) 构建命令行工具的库 symfony/console - Symfony命令行工作组件 symfony/process - Symfony命令执行组件 Boris - 一个微型的PHP REPL PsySH - 另一个PHP REPL Pecan - 一个事件驱动，非阻塞的shell GetOpt - 一个命令行选择解析器 OptParse - 另一个命令行选择解析器 Commando - 一个简单的命令行选择解析器 GetOptionKit - 同样还是一个命令行选择解析器 Cron Expression -计算cron运行日期的库 ShellWrap - 一个简单的命令行包装库 Hoa Console - 另一个命令行库 Shunt -一个在多台远程机器上并行运行的命令行库 Cilex - 构建命令行工具的小型框架 CLImate - 构建命令行工具的框架(可以输出颜色和特殊格式) Webmozart Console Silly - Silly CLI micro-framework based on Symfony Console php-shellcommand - A simple object oriented interface to execute shell commands in PHP 定时任务( Crontab ) 定时任务管理 crontab在 PHP 中的相关封装 Dispatcher - 基于Laravel的定时任务管理 swoole-crontab - 基于swoole的定时器程序，支持秒级处理 jobby - 一个 PHP 的定时任务管理器 cronlingo - Express crontabs as human friendly phrases 身份验证( Authentication and Authorization ) 实现身份验证模式的库 Sentinel - 一个身份验证和授权的框架 Sentinel Social - 一个用于社交网络身份验证的库 Opauth - 提供了 OAuth 认证的支持,提供统一标准的访问方法 OAuth2 Server - 一个OAuth2身份验证服务器、资源服务器和客户端库 OAuth2 Server - 一个OAuth2服务器实现 PHP oAuthLib - 另一个OAuth库 TwitterOAuth - 一个Twitter OAuth库 TwitterSDK - 一个经过完全测试的Twitter SDK Hawk - 一个Hawk HTTP身份验证库 HybridAuth - 一个开源的社交登录库 Lock - 一个 Access Control Lists (ACL) 系统库. OAuth 1.0 Client - 一个 OAuth 1.0 客户端库. OAuth 2.0 Client - 一个 OAuth 2.0 客户端库. Sentry - 认证和授权系统 EvaOAuth - 统一接口的 OAuth 登录 PHP 类库 JSON Web Token- JSON网络令牌库 php-jwt jwt jose - JSON签名和加密的库 slim-jwt-auth jwt-auth Sapient - the Secure API ENgineering Toolkit API消息传递安全校验 legalthings/sso - Simple Single Sign-On for PHP 标记( Markup ) 处理标记的库 Decoda - 一个轻量级的标记解析库 PHP Markdown - Markdown解析器 CommonMark PHP - 一个支持 CommonMark spec 的Markdown解析器. Parsedown - 一个Markdown解析器 Ciconia - 一个支持Github风格的Markdown解析器 Cebe Markdown - 一个快速、可扩展的Markdown解析器 HTML5 PHP - 一个HTML5解析和序列化的库 Emoji - 一个简单的处理emoji的类库 php-emoji - 一个emoji表情转换库 字符串( Strings ) 解析和操纵字符串的库 Agent - A PHP desktop/mobile user agent parser, based on Mobiledetect. ANSI to HTML5 - 一个将ANSI转换为HTML5的库 Patchwork UTF-8 - 处理UTF-8格式字符串的便携库 Hoa String - 另一个UTF-8格式的字符串库 Stringy - 一个多字节支持的字符串操纵库 Color Jizz - 一个处理和转换颜色的库 UUID - 生成UUIDs的库 Slugify - 一个将字符串转换为slug格式的库 Urlify - 一个Django URLify.js的PHP端口 Text - 一个文本处理库 SQL Formatter - 一个用于格式化SQL语句的库 UA Parser - 一个解析UA(User Agent)字符串的库 Device Detector - 另一个解析UA(User Agent)字符串的库 Mobile-Detect - 一个轻量级的检测移动设备的库(包括桌面设备) Browser - 检测关于用户的浏览器环境 colors.php - An easy way to add colors in your CLI scripts. 数字( Numbers ) 处理数字的库 Numbers PHP - 一个处理数字的库 Math - 处理较大数字的库 ByteUnits - 一个在二进制和测量系统中解析、格式化和转换字节单位的库 PHP Units of Measure - 一个测量单位间转换的库 PHP Conversion - 另一个测量单位间转换的库 LibPhoneNumber for PHP - PHP实现的Google电话号码处理系统库 hashids.php - 用来把整数生成唯一字符串（比如：通过加密解密id来隐藏真实id) Particle - PHP ID Generator | Implementation of Twitter Snowflake ID Generator 过滤和验证( Filtering ang Validation ) 用于过滤和验证数据的库 Filterus - 一个简单的PHP过滤库 Respect Validation - 一个简单的验证库 Valitron - 另一个数据验证库 Cake Validation - 另一个数据验证库 Illuminate validation package - Laravel的验证库 php-readability - 内容分析算法 Upload - 一个处理文件上传和验证的库 DMS Filter - 一个基于标注的过滤库 MetaYaml - 支持YAML、JSON和XML的一个模式验证库 ISO-codes - 验证不同ISO和ZIP编码的库 aura/filter - Aura 数据验证组件 symfony/validator - Symfony 数据验证组件 REST和API 用于开发restful APIs的库和Web框架 Apigility - 一个使用Zend Framework2构建的API构建器 Hateoas - 一个HATEOAS REST的web服务库 HAL - 一个超文本应用语言（HAL）构建库 Negotiation - 一个内容协商库 Drest -一个将Doctrine实体展现为REST资源结点的库 Restler - 一个将PHP方法展现为RESTful web API的轻量级框架 fractal - [最佳实践]数据返回的统一化处理 api-problem - A simple implementation of the api-problem specification graphql-php - 应用层查询语言库 GraphQL - 另一个应用层查询语言库 缓存( Caching ) 缓存数据的库 Alternative PHP Cache (APC) - PHP的开源操作码缓存 Doctrine Cache - 一个缓存库. Zend Cache - 另一个缓存库 Cake Cache - 一个用于缓存的库 Stash - 另一个缓存库 CacheTool - 一个清除APC/opcode缓存的命令行工具 PhpFastCache - PHP 缓存库 desarrolla2/Cache - 一个提供多种Adapter的缓存库 数据结构和存储( Data Structure and Storage ) 实现数据结构和存储技术的库 Illuminate\\Support\\Collection - Laravel提供的流畅、便利的封装来操控数组数据的集合库 Collections - 一个从Laravel拆离出的集合库 Ardent - 一个数据结构库 Cake Collection - 一个简单的集合库 Collections - 一个集合抽象库 Fractal - 一个将复杂数据结构转换为JSON输出的库 PHP Collections - 一个简单的集合库 Serializer - 用于序列化和反序列化数据的库 Zend Serializer - 另一个用于序列化和反序列化数据的库 PHP Object Storage - 一个用于对象存储的库 Totem - 一个管理和创建数据修改集的库 PINQ - PHP实时Linq库 JsonMapper - 一个将内嵌JSON结构映射到PHP类上的库 php-jsonq - A PHP query builder for JSON 通知( Notifications ) 关于通知的库 Nod - 一个通知库 Notificato - 一个处理推送消息的库 Notification Pusher - 设备推送通知的独立库 Notificator - 一个轻量级通知库 部署( Deployment ) 用于项目部署的库 Pomander - 一个PHP应用的部署工具 Rocketeer - PHP的快速和简单部署器 Envoy - 使用PHP运行SSH任务的工具 Plum - 一个部署库 Deployer - 一个部署工具 walle-web - 一个开源的web代码发布管理系统 国际化和本地化(Internationalisation and Localisation) 用于国际化(I18n)和本地化(L10n)的库 Aura Intl Cake I18n - 翻译和本地化消息 symfony/translation illuminate/translation Gettext - PHP library to collect and manipulate gettext (.po, .mo, .php, .json, etc) zend/i18n 第三方API( Third Party APIs ) 访问第三方API的库 mailgun-php - Mailgun’s Official SDK for PHP wechat - 让微信开发更简单 Qiniu/sdk - Qiniu Resource Storage SDK for PHP Qiniu/qshell - qshell是利用七牛文档上公开的API实现的一个方便开发者测试和使用七牛API服务的命令行工具。 Wafer - 快速构建具备弹性能力的微信小程序 GeoIP2-php - MaxMind GeoIP2 地理位置服务 pingpp-php - ping++聚合支付SDK 扩展( Extensions ) 帮助构建PHP扩展的库 Zephir - 用于开发PHP扩展的一种在PHP和C++间的编译语言 PHP CPP - 一个用于开发PHP扩展的C++库 PHP-X - C++ wrapper for Zend API PHP 安装(PHP Installation) 帮助安装和管理PHP HomeBrew - 一个OSX的包管理工具 HomeBrew PHP - HomeBrew中PHP的安装包 PHP OSX - 一个OSX中的PHP安装器 PHP Brew - 一个PHP版本管理工具和安装器 PHP Env - 另一个PHP版本工具 PHP Switch - 另一个PHP版本工具 PHP Build - 另一个PHP版本工具 VirtPHP - 一个创建和管理分离的PHP环境的工具 开发环境(Development Environment) 创建沙箱开发环境的软件和工具 Docker - 一个开源的应用容器引擎 Vagrant - 一个轻便的创建开发环境的工具 Ansible - 一个简单的业务流程框架 Puppet - 服务器自动化框架和应用 PuPHPet - 一个用于构建PHP开发虚拟机工具 Protobox - 另一个用于构建PHP开发虚拟机工具 Phansible - 另一个用于构建PHP开发虚拟机工具 centstead - Laravel local development environment base on vagrant and homestead Devilbox - A modern dockerized LAMP and MEAN stack alternative to XAMPP Homestead - 基于 Vagrant 的 PHP 开发环境 Laradock - 基于 Docker 的 PHP 开发环境 虚拟机(Virtual Machines) 替代的PHP虚拟机 HHVM - Facebook 开源的PHP虚拟机 HippyVM - 另一个PHP虚拟机 开发工具(Integrated Development Environment) 支持PHP的IDE Netbeans Eclipse for PHP Developers PhpStorm Web 应用程序(Web Applications) 基于Web的应用程序和工具 3V4L - Online PHP shell DBV - 数据库版本控制应用程序 PHP Queue - 管理队列的后端程序 MailCatcher - 一个接受和查看邮件的程序 Cachet - 一个开源的网站状态展示系统(如: status.github.com ) phpRedisAdmin - Redis 管理工具 phpPgAdmin - PostgreSQL管理工具 phpMyAdmin - MySQL管理工具 rockmongo - MongoDB管理工具 Grav - Powerful Flat-File CMS Piwik - 网页统计 YOURLS - 短网址生成系统 Nextcloud server - 开源私有云系统(a safe home for all your data) 基础设施(Infrastructure) 提供PHP应用程序和服务的基础设施 appserver.io - 基于PHP的多线程应用程序服务器 php-pm - 进程管理器,增压器和PHP应用程序的负载平衡器 laravel-swoole - 基于 swoole 的高性能HTTP Server laravel-s - 另一个基于 swoole 的高性能HTTP Server 数据库中间件( DB Proxy ) 用于读写分离、分库分表等 kingshard - 金山开源的数据库中间件 heisenberg - 百度开源的数据库中间件 Oceanus - 58同城开源的数据库中间件 Atlas - 360开源数据库中间件 DBProxy - 美团点评基于Atlas的数据库中间件 Mycat TiDB - 分布式数据库 mysql-proxy - Swoole开源的数据库中间件 RPC框架 远程过程调用框架 thrift - Apache Thrift grpc - Google的开源框架 protobuf Dubbo - 阿里巴巴开源的RPC框架 Motan - 微博轻量级RPC框架 Dubbox - 当当网维护的dubbox sofa-pbrpc - 百度开源的sofa-pbrpc yar Hprose - 高性能跨语言RPC hprose-php hprose-swoole 其他 Dora-RPC workerman-JsonRpc 异步网络通信框架( Asynchronous Event Driven Framework ) Swoole Workerman Gearman - 任务分发系统 phpdaemon ReactPHP Amp - A non-blocking concurrency framework for PHP applications. async - Easily run code asynchronously kraken-php - Asynchronous &amp; Fault-tolerant PHP Framework for Distributed Applications. 规则引擎( Rules Engine ) Hoa\\Ruler - Hoa项目的规则引擎 Ruler - 简单的无状态的规则引擎 Rules - PHP简易规则引擎 其他( Miscellaneous ) 不属于以上分类的有用的类库和工具 pinyin - 汉字转拼音的库 Pinyin - 汉字转拼音的库 class.upload.php - 文件上传处理类 php-paginator - 分页处理类 Underscore.php - Underscore.js的PHP实现 Flexihash - 一致性hash库 Eden - 一个PHP快速开发类库,它包含很多组件用来自动加载、事件驱动、文档系统、缓存、模板、国际化、数据库、web服务、支付网关、装载和云服务技术。 html-parser - html解析工具 PHPCrawl - PHP的爬虫框架 Tig - 命令行下的 Git 浏览器 copywriting-correct - 中英文文案排版纠正器 PHP-ML - PHP 机器学习库 BotMan - 聊天机器人库","categories":[{"name":"PHP相关","slug":"PHP相关","permalink":"https://syhyz1990.github.io/categories/PHP相关/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://syhyz1990.github.io/tags/PHP/"}]},{"title":"前端组件库","slug":"front-end-component-library","date":"2017-06-20T08:20:03.000Z","updated":"2018-06-05T08:23:06.575Z","comments":true,"path":"wiki/front-end-component-library.html","link":"","permalink":"https://syhyz1990.github.io/wiki/front-end-component-library.html","excerpt":"","text":"前端组件库 搭建web app常用的样式/组件等收集列表(移动优先) 0. 前端自动化(Workflow) 前端构建工具 Webpack - module bundler Yeoman - a set of tools for automating development workflow gulp - The streaming build system use-gulp grunt - the JavaScript Task Runner F.I.S - 前端集成解决方案 Web Starter Kit - 一个Google 提供的帮助开发者快速设置项目的工具集 node-prune - Remove unnecessary files from node_modules 前端模块管理器 Bower - A package manager for the web Browserify Component Duo RequireJS Sea.js LABjs - 文件加载器 css-modulesify - CSS模块加载器 css预处理器 Less - Less is More , Than CSS Sass - Syntactically Awesome Style Sheets Stylus - Expressive, dynamic, robust CSS 前端性能分析工具 analyze-css - CSS 选择器的复杂度和性能分析器 1. 前端UI框架(Frameworks) Bootstrap Foundation Amaze UI Semantic UI Pure CSS topcoat UIkit Material UI Materialize - 一个基于 Material Design 的 CSS 框架 Framework7 mui ionic framework Fries jQuery Mobile App.js Office UI Fabric - 微软 Office 前端团队的框架 Polymer - Google发布的Web组件构建框架 Layui - 经典模块化前端UI框架 2. JavaScript 框架汇总 JavaScript 框架 react ant-design - A UI Design Language ant-design-mobile - A configurable Mobile UI ant-design-pro - An out-of-box UI solution for enterprise applications Angular Vue.js - 数据驱动的组件化MVVM库(用于创建web交互界面和数据双向绑定) awesome-vue Element - 基于 Vue 2.0 构建了一套完整的桌面 UI 组件库 Vuex - 一个专门为 Vue.js 应用设计的状态管理架构 vant - 轻量、可靠的移动端 Vue 组件库，商城端 at-ui - 一款基于 Vue.js 2.0 的前端 UI 组件库，主要用于快速开发 PC 网站产品 Mint UI：基于 Vue.js 的移动端组件库 Vux - 基于 Vue 和 WeUI 的 UI 组件库 vonic - 基于 Vue.js 和 Ionic 的移动 UI 组件库 vuetify - vue2.0组件库 iView - 一套基于 Vue.js 的高质量 UI 组件库,主要用于快速开发 PC 网站后台 vue-i18n preact - React 的 3kb 轻量化方案，拥有同样的 ES6 API jQuery Backbone.js ember.js Ractive.js KISSY Zepto.js Vanilla JS Can.js Avalon T3 JavaScript Framework - 一个用于搭建大型Web应用的客户端JS框架 jsblocks - Better MV-ish Framework 从简单 UI 到复杂单页应用都适用 轻量级JavaScript框架 Min.js - Super minimal selector and event library skel.js - A lightweight responsive framework Sprint.js - 一个高性能、小体积的 DOM 操作库 knockout PhantomJS - 一个基于 WebKit 的服务器端 JavaScript API 函数式反应型编程框架 FRP (Functional Reactive Programming) library Bacon.js - A small functional reactive programming lib for JavaScript. Flapjax - 一个支持FRP的JavaScript框架 混合开发框架 Electron - 使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用 React Native - 使用JavaScript和React构建原生手机APP electron-react-boilerplate - Electron应用程序样板(基于React、Redux、React Router、Webpack、React Transform HMR用于应用程序快速开发) 微信小程序开发库 weui-wxss - WeUI for 小程序 为微信小程序量身设计 wepy - 小程序组件化开发框架 zanui-weapp - 高颜值、好用、易扩展的微信小程序 UI 库，Powered by 有赞 mpvue - 基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系 minui - 基于规范的小程序 UI 组件库，自定义标签组件，简洁、易用、工具化 JavaScript 工具库 underscore.js Underscore.string.js字符串操作库 functional.js Lo-Dash - A JavaScript utility library Lazy.js - a functional utility library for JavaScript Fn.js Way.js - 双向数据绑定库 boiler - a utility library that makes tasks in JavaScript easier 快捷键操作 KeyboardJS - A JavaScript library for binding keyboard combos without the pain of key codes and key combo conflicts. mousetrap - Simple library for handling keyboard shortcuts in Javascript Keys.js - 应用快捷键 simple-hotkeys jquery.hotkeys Mousetrap - 键盘快捷键操作 AlloyLever - 移动web开发者工具面板 3. 前端游戏框架 cocos2d-html5 Egret Engine LimeJS EaselJS three.js AlloyStick The-Best-JS-Game-Framework CanvasEngine Quintus Stage.js phaser - 一个快速、免费、开源的 HTML5 游戏框架 4. ui组件库(CSS Framework) WeUI - 微信官方UI库 jQuery WeUI - WeUI的jQuery版本 FrozenUI - 腾讯移动端组件库 Pure CSS Components magic-of-css Primer - The CSS toolkit and guidelines that power GitHub light7 - A Light and easy to use UI Lib Spectre.css - 轻量、响应式的现代 CSS 框架 mobi.css - 一个轻量、灵活的移动端 CSS 框架 5. 基础模版 浏览器统一(Cross Browser) HTML5 BOILERPLATE Modernizr Normalize.css HTML5 Shiv - 让ie浏览器成为支持html5的浏览器的解决方法 cssFx - 为CSS3自动生成浏览器前缀 -prefix-free - Break free from CSS prefix hell ieBetter.js - make ie browser like a morden browser main for ie6~ie8 es6-promise - Promise 对象的兼容 响应式 Responsive - 响应式布局 Enquire.js - Awesome Media Queries in JavaScript Free Wall - 创建桌面，移动和平板的动态网格布局 适配方案 MetaHandler.js：移动端适配各种屏幕无痛工具脚本 lib-flexible: 移动端自适应方案 参考: 使用Flexible实现手淘H5页面的终端适配 flexible demo 1 flexible demo 2 pageResponse responsive-page 6. 排版 yue.css typo.css chinese-copywriting-guidelines - 中文文案排版指南 7. 网格系统 grid Flexbox Grid MasonJS - creating a perfect grid 8. 路由和链接(Routing And URLs) History.js - gracefully supports the HTML5 History/State APIs jquery-pjax - pushState+ajax jquery-address - Deep Linking page.js - Micro client-side router crossroads.js hash.js path.js director.js - 前端路由库(通过#符号进行路径组织,结合vue的component可进行单页的局部模块刷新) URI.js Roadcrew.js SpeakingURL uparams - An URL params parser StateMan - 一个处理深层次单页系统的路由库 qs - A querystring parser with nesting support 9. UA 识别 detector ua-parser-js platform.js 10. 表单处理10.1 表单验证(Form Validator)/表单提示 Validator Parsley jquery.form.js - jQuery Form Plugin Validform validator.js jquery-validation - jQuery Validation Plugin formvalidator.js Fort.js – 表单填写进度提示 mailcheck - 用于检测email地址的域名 Floatlable.js - 输入时显示placeholder文本 jQuery Label Better validator.js 10.2 &lt; input &gt; 相关 cleave.js - 格式化你的输入内容 10.3 &lt; select &gt; 相关 Chosen Select2 bootstrap-select 10.4 单选框/复选框相关 iCheck - 增强复选框和单选按钮 Switchery - iOS 7 style switches for your checkboxes 10.5 上传组件 jQuery File Upload Plugin 百度 Web Uploader uploadify Plupload Fine Uploader arale-upload - 轻量级 iframe and html5 file uploader Dropzone.js - 文件上传库(可获取文件mime, 文件大小等; 针对图片可生成缩略图,获取图片宽度,高度) flow.js localResizeIMG - 前端本地客户端压缩图片，兼容IOS，Android，PC simple-uploader 10.6 日期选择 tui.calendar - A JavaScript calendar that everything you need. Both Date and Time picker widget based on twitter bootstrap GMU 日历组件 Mobiscroll Pikaday - 日期选择器 价格日历 PriceCalendar - 酒店价格日历 API文档 DEMO price-calendar - 价格日历 price_calendar - 含有商品价格的日历控件 10.7 取色 Colorpicker plugin for Twitter Bootstrap average-color - Get Average Color of Image 10.8 标签插件(Tag) TaggingJS – 可以灵活定制的 jQuery 标签系统插件 selectize.js Bootstrap Tags Input jQuery-Tags-Input 10.9 自动完成插件 At.js - 一个Twitter/微博样式的@自动完成插件 jquery-textcomplete - 智能搜索提示框/自动补全 typeahead.js - a fast and fully-featured autocomplete library 10.10 样式修正 autosize - 使文本框自动适应所输入的内容 11. 图表绘制/图形库(Graphics) Highcharts Chart.js - Simple HTML5 Charts using Canvas 百度 ECharts Chartist.js D3.js - A JavaScript visualization library for HTML and SVG. intro-to-d3 - a D3.js tutorial Bonsai - 一个功能强大的JavaScript图形库 epoch - 数据图表可视化 Vis.js Coutour.js zrender - 一个轻量级的Canvas类库，MVC封装，数据驱动，提供类Dom事件模型，让canvas绘图大不同！ 12. 日期格式化 &amp; 时间轴 Moment.js - 日期处理 Day.js - 日期处理 Smart Time Ago - 显示相对时间 timeline.js timeago.js date-utils - Date Pollyfills for Node.js and Browser 13. 页面交互13.1 Slider slick - the last carousel you’ll ever need Swipe - the most accurate touch slider Swiper - Most modern mobile touch slider iscroll - Smooth scrolling for the web iSlider - 移动端滑动组件 OwlCarousel - create beautiful responsive carousel slider jquery-mousewheel - jQuery鼠标滚轮滚动侦测插件 Glide.js - 轻量级滑块组件 PhotoSwipe TouchSlide - 触屏滑动特效(焦点图,Tab切换) better-scroll - inspired by iscroll, and it supports more features and has a better scroll perfermance 13.2 瀑布流 Masonry Isotope - Filter &amp; sort magical layouts Bricklayer 13.3 懒加载/加载监听/预加载 imagesLoaded Echo.js lazySizes jquery_lazyload BttrLazyLoading lazyload.js layzr.js - 一个小巧快速的图片懒加载库 waitForImages - 图片加载监听库 PxLoader - JS预加载库:实现图片、声音等各种文件的预加载功能 bindWithDelay - jQuery Plugin For Delayed Event Execution TypeWatch - 停止输入时调用 13.4 图片轮播(幻灯片)/图片展示 FlexSlider unslider - 小而美的轮播库 prettyPhoto FlickerPlate - A cool jQuery plugin that lets you flick through content. Holder.js - Client-side image placeholders. RowGrid.js - 在径直的行里放置图片 ImageLightbox.js - 灯箱效果 JQuery Panorama Viewer - 全景视图 Intense Images - 全屏查看图片 Picturefill - 一个响应式图片 JS 插件 zoom.js - 一个 jQuery 图片放大插件 watermarkjs - 一个在浏览器中添加图片水印的 JS 库 responsive-images.js Turntable.js - 轻易实现图像的3D旋转 ResponsifyJS - 让图像完全响应式而不会牺牲图像的主要部分 react-slick - React 实现的轮播图插件 13.5 图片剪裁/图片处理/图片转换 cropperjs - 图片裁切 Jcrop - Image Cropping Plugin for jQuery croppic - an image cropping jquery plugin smartcrop.js - 智能图片裁剪库 jQuery.eraser - 图像擦除插件 DD_belatedPNG.js - 让IE6支持透明PNG图片 FocusPoint.js 实现图片的响应式裁剪 imgareaselect CSSgram - CSS 实现的 Instagram 滤镜库 instagram.css - 另一个 CSS 实现的 Instagram 滤镜库 antimoderate - 图片模糊库 vue-cropper - Vue.js 的图片剪裁插件 react-cropper - React 的图片剪裁插件 react-image-crop - React 的图片剪裁插件 rasterizeHTML.js - HTML转图片(网页截图) html2canvas - HTML转图片(实现纯JS网页截图) dom-to-image - HTML转图片 domvas - HTML转图片 13.6 进度条/加载动画(Loading) NProgress.js progress.js Pace - Automatic page load progress bar jquery-ajax-progress nanobar - Very lightweight progress bars. waitMe - 很漂亮的loading效果 spin.js sonic.js fakeLoader.js loaders.css - 一个为性能优化的实现加载动画效果的 CSS 框架 css-loaders Sausage - 跟踪滚动条并记录当前阅读所处节点 loading.io - 一个 Loading 图标的网站 13.7 侧滑插件(offcancas) pushy - a responsive off-canvas navigation menu Slideout.js - 一个用于移动 Web 应用的触摸滑出式导航菜单 13.8 菜单(Menu) SuperFish - 基于jQuery的级联下拉菜单 Responsive Nav - 响应式导航 metisMenu - A jQuery menu plugin 13.9 滚动侦测(ScrollSpy) jquery-scrollspy(1) jquery-scrollspy(2) Waypoints ScrollMagic - 像进度条一样使用滚动条 13.10 滚动加载更多/下拉刷新(Pull to Refresh) jScroll web-pull-to-refresh pulltorefresh RubberBand.js - add pull-to-refresh functionality to any page. 13.11 平滑滚动插件(Smooth Scroll) jquery-smooth-scroll jquery.scrollTo - 平滑滚动到页面指定位置 smooth-scroll scrollUp elevator.js - 一个模拟电梯运行“返回顶部”的 JS 插件 13.12 全屏滚动/全屏切换 pagePiling.js - 全屏滚动效果 fullPage.js onepage-scroll zepto.fullpage - 专注于移动端的fullPage.js screenfull.js - 切换全屏模式 13.13 分屏滚动 multiscroll.js - 分屏滚动效果 13.14 转场效果 Animsition - 页面切换时的过渡效果 13.15 固定元素(Sticky) sticky - jQuery Plugin for Sticky Objects jquery.pin - 固定页面元素 stickUp Slinky.js - 堆叠头部创建滑动导航列表 13.16 触控事件 Hammer.js jquery.event.move.js 13.17 拖拽组件 Draggabilly - 专注于拖拽功能的 JS 库 dragula - 一个让拖放操作变简单的 JS 库 GridList - 可拖拉的响应式列表库 13.18 隐藏或展示页面元素 Headroom.js - 在不需要页头时将其隐藏 Readmore.js - 内容显示与隐藏插件 oriDomi - 像指一样折叠Dom元素 13.19 滚动条(Scrollbar) jScrollPane jquery.scrollbar perfect-scrollbar nanoScrollerJS tinyscrollbar 13.20 视差滚动(Parallax Scrolling) parallax.js jparallax skrollr 13.21 缩放 (Zooming) zoom.js - 一款效果很独特的页面内容缩放插件 zoom.js - 一个 jQuery 图片放大插件 jQuery Zoom - mouseover时图片缩放效果 14. 代码高亮插件/代码编辑器 google-code-prettify highlight.js Rainbow ACE CodeMirror Crayon Syntax Highlighter prism - Lightweight, robust, elegant syntax highlighting. 15. UI Icon 组件 Font Awesome Glyphter: The SVG Font Machine Perfect Icons iconizr Cikonss - 纯CSS实现的响应式Icon Simple Icons 16. 动画(Animate) animate.css - A cross-browser library of CSS animations. Transit - CSS transitions and transformations for jQuery anime.js - Javascript 动画引擎 WOW - 在滚动过程中展示CSS动画效果(默认触发animate.css动画) AniJS - A Library to Raise your Web Design without Coding Move.js - 简化CSS3动画的JS库 ScrollMe – 在网页中加入各种滚动动画效果 Effeckt.css - A Performant Transitions and Animations Library NEC动画库 csshake - CSS classes to move your DOM magic - CSS3 Animations with special effects SpinKit Velocity.js - 加速JavaScript动画 lenticular.js - 响应倾斜或鼠标事件创建图片动画 jQuery Interactive 3D - Create a 3D interactive object using images AnimateScroll - A Simple jQuery Plugin for Animating Scroll Blast.js - 把动画和样式注入到文本中 Bounce.js - 一个用于制作漂亮 CSS3 关键帧动画的 JS 库 Sticker.js - create a Sticker Effect scrollReveal.js - 元素进入可视区域自动触发设置好的动画 stroll.js - CSS3 list scroll effects jQuery Easing - 动画效果扩展 animations - CSS3 ANIMATION CHEAT SHEET iconate.js：将 icons 增加动画效果的 JS 库 Odometer - 数字之间的垂直切换 Hover - 悬停效果 Hover.css - 很多鼠标Hover态的效果 imagehover.css - 为图片添加悬停效果 iHover - 图片悬停效果 ImageCaptionHoverAnimation Bootstrap Hover Image Gallery Multi-touch gestures library - Web手势库 AlloyFinger - 腾讯 AlloyTeam 出品的超级小的 Web 手势库 17. 本地存储 cross-storage - Cross domain local storage localForage pouchdb basil.js Neurosync - JavaScript 本地离线 ORM 库 LokiJS - 性能优先的 JavaScript 内存数据库 turbolinks - Javascript pushState 18. 模板引擎 doT.js mustache.js Handlebars.js artTemplate baiduTemplate JSRender EJS - JavaScript Templates Juicer - A Light Javascript Templete Engine. Tempo json2html Hogan.js - JavaScript templating from Twitter. Dust.js - Linkedin维护的项目 nunjucks - A powerful templating engine 19. 通知组件/弹框组件/模态窗口 Notify.js(Web Notifications API) alertify.js AlertifyJS SweetAlert Messenger - 非常酷的弹框组件 PNotify Notify.js - A simple, versatile notification library Remodal - 模态窗口插件 action.js - 极简的tip和Modal弹窗效果 Modaal - 一个创建弹出窗口的jQuery插件 Vex - 可以实现3D动效的弹出对话框堆叠效果 20. 提示控件(Tooltips) hint.css - 一款非常小巧的提示框效果 qTip2 - Pretty powerful tooltips tooltip - CSS Tooltips tooltipster - A jQuery tooltip plugin grumble.js - 气泡形状的提示（Tooltip）控件 Ouibounce - 离站提示控件 intro.js - 一个创建引导式网站介绍功能的 JS 库 data-tip.css - 纯 CSS 实现的工具提示 21. 对话框/遮罩层/弹出层(lightbox) fancyBox - Fancy jQuery lightbox jquery-lightbox - The popular lightbox script, ported to jQuery Colorbox - a jQuery lightbox artDialog - 经典的网页对话框组件 DialogEffects jQuery blockUI - Page or element overlay layer - web弹出窗/层 22. 文档/表格/PDF Backgrid.js - 强大的表格组件 handsontable - 在线可编辑excel表格 jQuery Bootgrid - 用于ajax生成动态表格 DataTables - Table plug-in for jQuery PDF.js - 一个 JavaScript 编写的 PDF 阅读器 jsPDF - Generate PDF files in JavaScript Recline.js - 灵活操作和展示数据 Dynatable - 交互式表格插件 fattable - 创建无限滚动无限行列数的表格 Clusterize.js - 一个轻松显示大数据集的 JS 插件 Uniform -表单美化插件 tableExport - 导出HTML Table为 Excel、PDF 等 SheetJS/js-xlsx - 生成Excel文件并下载 23. 目录树插件 zTree_v3 - jQuery Tree Plugin jstree - jQuery Tree Plugin fancytree - Tree plugin for jQuery 24. 前后端交互24.1 Ajax模块 fetch - A window.fetch JavaScript polyfill reqwest - browser asynchronous http requests ajax - Standalone AJAX library then-request browser-request superagent minAjax.js qwest - 第三方的Ajax库 axios - Promise based HTTP client for the browser and node.js whatwg-fetch jsonp - A simple JSONP implementation isomorphic-fetch - Isomorphic WHATWG Fetch API, for Node &amp; Browserify 24.2 SSE (Server-Sent Events) SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据. EventSource 24.3 Web Sockets25. 音频/视频 jPlayer - HTML5 Audio &amp; Video for jQuery video.js - HTML5 &amp; Flash video player Accessible HTML5 Video Player - PayPal 开源的 HTML5 视频播放器 Clappr - 开源的Web视频播放器 Plyr - A simple HTML5 media player FitVids.js - A lightweight, easy-to-use jQuery plugin for fluid width video embeds. BigVideo.js - The jQuery Plugin for Big Background Video BigScreen - A simple library for using the JavaScript Full Screen API Vide - 视频背景 winamp2-js Buzz - A Javascript HTML5 Audio library MediaElement.js 26. 按钮 Buttons - A CSS button library ButtonComponentMorph ProgressButtonStyles CreativeButtons CSS3 buttons jquery.onoff - Interactive, accessible toggle switches for the web. Flipside - 一个能过渡到对话框的按钮 27. 富文本编辑器/Markdown编辑器/Markdown解析器 Simditor - 简单快速的富文本编辑器 BachEditor - 一个有情怀的编辑器 TinyMCE bootstrap-markdown marked - markdown解析器 Markdown Plus Editor.md - 开源在线Markdown编辑器 stackedit Redactor Text Editor micromarkdown.js - 轻量级的md解析器 wangEditor - 支持移动端的轻量级web富文本框 CKEditor - 可视化 HTML 编辑器 Quill - 富文本编辑器 28. 内容提取(Readability) Readability json.human.js - Json Formatting for Human Beings 29. 颜色(CSS Colors)/SVG/Canvas CSS Colours SVGeneration SVGMagic - 自动的创建PNG来兼容不支持SVG的浏览器 Adaptive Backgrounds - 从图片抽取主要颜色和应用到父元素 Seen.js - 渲染3D场景为SVG或者HTML Canvas jquery-color - 可以动态改动颜色 30. 选项卡(Tabs) Easy Responsive Tabs to Accordion Responsive-Tabs ion.tabs - jQuery tabs plugin jQuery-EasyTabs tabulous.js 31. 文本处理 ZeroClipboard - 文本复制插件 clipboard.js Bigfoot - 点击文章中的脚注弹窗显示 Annotator - 文本注解插件，可以包括注释、标签、用户等 Succinct - 用作截断多行文本,后面添加省略号 Flowtype.js - 自动调整字体大小和行号 flat-shadow FitText - A jQuery plugin for inflating web type shine.js - 实现漂亮阴影 Type Rendering Mix - 文本渲染引擎 jquery-expander - 阅读更多 Typed.js - 输入模拟插件 jQuery.dotdotdot - 多行文本溢出显示省略号 baffle.js - 文本互动效果 32. 布局(Layout) 分隔面板(Split Panel) split-pane jQuery UI Layout 33. 演示/幻灯片 reveal.js - The HTML Presentation Framework bespoke.js - DIY Presentation Micro-Framework impress.js shower deck.js 34. 国际化(i18n) jquery-i18n i18next.js jsperanto.js jed.js messageformat.js Polyglot.js 35. 邮件模板(Email Templates) responsive-html-email-template 36. 移动端优化(Optimizing Mobile Performance) FastClick - 处理移动端 click 事件 300 毫秒延迟 tappy jquery-fast-click 37. HTTP请求相关 pako - HTTP 请求正文压缩 参考阅读: 如何压缩 HTTP 请求正文 HTTP 请求正文压缩 DEMO 38. 下载组件 download Downloadify 39. 加密/转码 crypto-js - JavaScript library of crypto standards. ulid - 生成UUID类库 RSA in JavaScript - 用RSA加密实现Web数据加密传输 40. 调试 debug - A tiny JavaScript debugging utility modelled after Node.js core’s debugging technique. Works in Node.js and web browsers vConsole - 一个针对手机网页的前端 console 调试面板 41. 实用工具/其他插件 jquery-cookie JavaScript Cookie InstantClick - 预加载用户可能会点击的一些链接 Async.js - 异步操作 jquery.qrcode.js - 生成二维码的 jQuery 插件 qrcodejs - JS生成QRCode的库 nakedpassword - 用脱衣女帮助检测密码强度 KityMinder - 脑图编辑工具 MixitUp - 动画过滤和排序 JQuery Tip Cards - 创建卡片交互的cards布局 Fallback.js - JavaScript library for dynamically loading CSS and JS files. swfobject prettyprint.js - An in-browser JavaScript variable dumper Shepherd - 为应用创建用户指南 RulersGuide.js - 类似PhotoShop标尺的js库 Gremlins.js - Monkey 测试库 RoughDraft.js - 简单快速的创建交互式的 HTML 模型的原型工具 favico.js - 动态改变浏览器标签栏中的网站图标 pageguide - 网页向导 jsdiff - js diff 算法 ES6( ECMAScript 2015 )ES6转码器(ES6 to ES5) Babel - 一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行 babelify - 将babel引入到Gulp, Grunt, npm run等构建过程 traceur-compiler - Traceur is a JavaScript.next-to-JavaScript-of-today compiler ES6入门 ECMAScript 6入门 - 阮一峰老师的开源的JavaScript语言教程 Learn ES2015 ES6 - New features Overview &amp; Comparison ES6 Overview in 350 Bullet Points es6features 设计模式( JavaScript Patterns ) javascript-patterns jquery-patterns - A variety of jQuery plugin patterns Learning JavaScript Design Patterns 在线工具( Online Tools ) jsbin - Collaborative JavaScript Debugging App jsbin@Github jsfiddle jsbeautifier - Online JavaScript beautifier resume.github.com 前端开发工具1. 开发工具 Sublime Text 2. 调试工具 Fiddler Weinre Rythem csscss - 用于检查css代码冗余 FECS - 基于 Node.js 的前端代码检查工具 JSON Server - 模拟 API swagger-ui - 基于REST的API测试/文档 3. 模拟数据( Fake ) JSONPlaceholder json-server - Get a full fake REST API lowdb - A small local JSON database powered by lodash Mock.js - 一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试 4. 接口管理 RAP - Web接口管理工具，开源免费，接口自动化，MOCK数据自动生成，自动化测试，企业级管理 5. 浏览器扩展(Chrome Extensions) Postman - REST Client Fiddler - Fiddler for Chrome Extension WEB前端助手(FeHelper) Web Developer Wappalyzer - 分析网站应用的技术栈 HTTP Status Chrome Logger ColorZilla ColorPick Eyedropper Code Cola 1px AlloyDesigner - 前端重构开发辅助工具 Fontface Ninja PageSpeed Insights (by Google) Redirect Path Responsive Web Design Tester Window Resizer CSSViewer IE Tab Clear Cache JSONView Image Downloader Pretty Beautiful Javascript - 可以自动格式化混淆的js文件 JavaScript Errors Notifier CSS Diff - 在线比对页面上两个元素的CSS样式差异 WhatFont- 识别网页所使用的字体 前端参考集 frontend-guidelines - Some HTML, CSS and JS best practices. frontend-dev-bookmarks Codrops - Useful resources Front-end Code Standards &amp; Best Practices awesome-javascript Front-end-tutorial - 前端涉及的所有知识体系 awesome-vue 前端编码规范( Standard Style ) Airbnb 的 JavaScript 编码规范 JavaScript Standard Style clean-code-javascript - javascript 编码风格指南 spec - 百度前端团队代码规范 cheatsheet - 标签的内容清单 Front-End-Checklist - The perfect Front-End Checklist for modern websites and meticulous developers http://frontendchecklist.com 30-seconds-of-code 30-seconds-of-css project-guidelines - JavaScript工程项目的一系列最佳实践策略 react-in-patterns - React 模式 PWA-Book-CN - Progressive Web Apps (PWA) 中文版 javascript-algorithms - JavaScript 算法与数据结构 书籍( Frontend-related Books ) Front-End Developer Handbook 2016 Front-End Developer Handbook 2017 Front-End Developer Handbook 2018 前端工程师手册 前端工程师手册 - 包括前端开发实践、学习前端开发、前端开发工具","categories":[{"name":"技术文档","slug":"技术文档","permalink":"https://syhyz1990.github.io/categories/技术文档/"}],"tags":[]}]}